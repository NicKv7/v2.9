Dialog_Register(playerid, response, inputtext[])
{
	new file[100], Name[MAX_PLAYER_NAME]; 
	GetPlayerName(playerid, Name, sizeof(Name)); 
	format(file, sizeof(file), PlayerFile, Name); 
	switch (response) 
	{
		case 1: 
		{
			if(strlen(inputtext)>0)
			{
				format(APlayerData[playerid][PlayerPassword], 50, "%s", inputtext);
				PlayerFile_Create(playerid);
				PlayerFile_Load(playerid);
				SendClientMessage(playerid, 0xFFFFFFFF, TXT_AccountRegistered);
				APlayerData[playerid][LoggedIn] = true;
			}
			else
			{
				SendClientMessage(playerid, 0xFFFFFFFF, TXT_WrongPassword);
				Kick(playerid);
			}
		}
	    case 0: 
		{
			SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerMustRegister);
			Kick(playerid);
		}
	}
	return 1;
}
Dialog_Login(playerid, response, inputtext[])
{
	switch (response) // Check which button was clicked
	{
	    case 1: // Player clicked "Login"
		{
			// Check if the player entered a password
			if (strlen(inputtext) > 0)
			{
				// Check if the entered password is the same as the password saved in the player's account
			    if (strcmp(APlayerData[playerid][PlayerPassword], inputtext, false) == 0)
				{
					APlayerData[playerid][LoggedIn] = true; // The player has logged in properly
                    BankFile_Load(playerid); // Load your bank account (if it exists, the player will be notified about this)
					SendClientMessage(playerid, 0xFFFFFFFF, TXT_LoggedIn); // Send a message to the client to inform him that he logged in properly
				}
				else
				{
					SendClientMessage(playerid, 0xFFFFFFFF, TXT_WrongPassword);
					Kick(playerid);
				}
			}
			else
			{
				SendClientMessage(playerid, 0xFFFFFFFF, TXT_WrongPassword);
				Kick(playerid);
			}
		}
	    case 0: // Player clicked "Cancel"
		{
			// Show a message that the player must be logged in to play on this server
			SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerMustLogin);
		    // Kick the player
			Kick(playerid);
		}
	}

	return 1;
}
Dialog_Rescue(playerid, response, listitem)
{
	if(!response) return 1;
	switch (APlayerData[playerid][PlayerClass])
	{
		case ClassTruckDriver:
		{
			switch (listitem)
			{
				case 0: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -525.0, -502.0, 26.0, 0.0, 0, 0, 0, 0, 0, 0);
				case 1: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -74.7, -1137.5, 4.5, 0.0, 0, 0, 0, 0, 0, 0);
				case 2: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1457.0, 975.5, 11.0, 0.0, 0, 0, 0, 0, 0, 0);
				case 3: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -2136.0, -247.5, 36.5, 270.0, 0, 0, 0, 0, 0, 0);
				case 4: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1766.5, -2040.7, 14.0, 270.0, 0, 0, 0, 0, 0, 0);
				case 5: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -546.0, 2594.0, 54.0, 270.0, 0, 0, 0, 0, 0, 0);
				case 6: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 332.0, 900.0, 25.0, 205.0, 0, 0, 0, 0, 0, 0);
				case 7: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -1575.0, -2724.0, 49.0, 146.0, 0, 0, 0, 0, 0, 0);
			}
		}
		case ClassBusDriver:
		{
			// Set the spawn coordinates based on the selection in the list
			switch (listitem)
			{
				case 0: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1809.0, -1905.0, 13.6, 90.0, 0, 0, 0, 0, 0, 0);
				case 1: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -1983.0, 110.0, 27.7, 180.0, 0, 0, 0, 0, 0, 0);
				case 2: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1060.0, 1260.0, 11.0, 270.0, 0, 0, 0, 0, 0, 0);
			}
		}
		case ClassPilot:
		{
			// Set the spawn coordinates based on the selection in the list
			switch (listitem)
			{
				case 0: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 2010.0, -2345.0, 13.6, 90.0, 0, 0, 0, 0, 0, 0);
				case 1: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -1211.0, -105.0, 14.2, 135.0, 0, 0, 0, 0, 0, 0);
				case 2: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1630.0, 1615.0, 10.9, 90.0, 0, 0, 0, 0, 0, 0);
			}
		}
		case ClassPolice:
		{
			// Set the spawn coordinates based on the selection in the list
			switch (listitem)
			{
				case 0: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1568.5, -1693.5, 6.0, 180.0, 0, 0, 0, 0, 0, 0);
				case 1: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -1590.0, 716.25, -5.0, 270.0, 0, 0, 0, 0, 0, 0);
				case 2: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 2275.0, 2460.0, 10.9, 90.0, 0, 0, 0, 0, 0, 0);
			}
		}
		case ClassCourier:
		{
			// Set the spawn coordinates based on the selection in the list
			switch (listitem)
			{
				case 0: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 798.0, -618.75, 16.4, 0.0, 0, 0, 0, 0, 0, 0);
				case 1: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), -1849.25, -135.0, 12.0, 90.0, 0, 0, 0, 0, 0, 0);
				case 2: SetSpawnInfo(playerid, 0, GetPlayerSkin(playerid), 1050.5, 1931.0, 10.9, 270.0, 0, 0, 0, 0, 0, 0);
			}
		}
	}

	SpawnPlayer(playerid); // Force the player to spawn at the requested coordinates
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerRescued); // Send the player a message that using "/rescue" costs $200
	// Reduce the player's money by 200
	RewardPlayer(playerid, -200, 0);

	return 1;
}
Dialog_BuyLicenses(playerid, response, listitem)
{
	if(!response) return 1;
	switch (listitem)
	{
		case 0:
		{
			if (APlayerData[playerid][PlayerClass] == ClassTruckDriver)
			{
				if (APlayerData[playerid][TruckerLicense] == 0)
				{
					if ((APlayerData[playerid][PlayerMoney] >= 50000) && (APlayerData[playerid][PlayerScore] >= 100))
					{
						RewardPlayer(playerid, -50000, -100);
						APlayerData[playerid][TruckerLicense] = 1;
						SendClientMessage(playerid, 0xFFFFFFFF, TXT_TruckerLicenseBought);
           				GameTextForPlayer(playerid, "~g~licenca adquirida!", 4000, 3);
					}
					else
					    SendClientMessage(playerid, 0xFFFFFFFF, TXT_TruckerLicenseNotEnoughMoney);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_TruckerLicenseOwned);
			}
			else
				SendClientMessage(playerid, 0xFFFFFFFF, TXT_TruckerLicenseWrongClass);
		}
		case 1:
		{
			if (APlayerData[playerid][PlayerClass] == ClassBusDriver)
			{
				if (APlayerData[playerid][BusLicense] == 0)
				{
					if ((APlayerData[playerid][PlayerMoney] >= 25000) && (APlayerData[playerid][PlayerScore] >= 50))
					{
 						RewardPlayer(playerid, -25000, -50);
						APlayerData[playerid][BusLicense] = 1;
						SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusLicenseBought);
           				GameTextForPlayer(playerid, "~g~licenca adquirida!", 4000, 3);
					}
					else
					    SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusLicenseNotEnoughMoney);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusLicenseOwned);
			}
			else
				SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusLicenseWrongClass);
		}
        case 2:
        {
            if(APlayerData[playerid][WeaponLicense] == 0)
            {
                if ((APlayerData[playerid][PlayerMoney] >= 100000) && (APlayerData[playerid][PlayerScore] >= 200))
                {
                    RewardPlayer(playerid, -100000, -200);
                    APlayerData[playerid][WeaponLicense] = 1;
                    SendClientMessage(playerid, 0xFFFFFFFF, TXT_WeaponLicenseBought);                          
          			GameTextForPlayer(playerid, "~r~porte de armas~n~adquirido!", 4000, 3);
                }
                else
                   SendClientMessage(playerid, 0xFFFFFFFF, TXT_WeaponLicenseNotEnoughMoney);
            }
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, TXT_WeaponLicenseOwned);
		}
	}
    return 1;
}
Dialog_Radios(playerid, response, listitem)
{
	if(!response) return 1;
	switch (listitem)
	{
		case 0:
		{
            PlayAudioStreamForPlayer(playerid, "http://radiofusion.com.br/fusion.asx", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1); //fusion
		}
		case 1:
		{
            PlayAudioStreamForPlayer(playerid, "http://servidor21.dnip.com.br:9936", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1);   //sertanejo
		}
        case 2:
        {
            PlayAudioStreamForPlayer(playerid, "http://64.15.147.220:7120", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1);  //forró
		}
        case 3:
        {
            PlayAudioStreamForPlayer(playerid, "http://184.154.6.69:7098", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1); //funk melody
        }
        case 4:
        {
            PlayAudioStreamForPlayer(playerid, "http://64.56.64.72:10452", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1); //funk
        }
        case 5:
        {
            PlayAudioStreamForPlayer(playerid, "http://64.120.251.82:7220", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1); //Rock
        }
        case 6:
        {
            PlayAudioStreamForPlayer(playerid, "http://174.123.189.170:8700", 258.4893, -41.4008, 1002.0234, 9999999999.0, 1); //Anos 80
        }
        case 7:
        {
            StopAudioStreamForPlayer(playerid);
        }
    }
    return 1;
}
Dialog_Q(playerid, response, listitem)
{
	if(!response) return 1;
	switch (listitem)
	{
		case 0:
		{
            Kick(playerid);
		}
		case 1:
		{
            //     
        }
    }
    return 1;
}

Dialog_TruckerSelectJobMethod(playerid, response, listitem)
{
	new ProductList[50], NumProducts, TotalLoadList[1000];

	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Select what to do after the player chose "Select your own load" or "Auto assigned load"
	switch (listitem)
	{
		case 0: // Let the player choose his own load
		{
			switch (GetVehicleModel(GetPlayerVehicleID(playerid))) // Check the vehicle-model of the player to decide which loads the player can carry
			{
				case VehicleFlatbed, VehicleDFT30: // If the player's vehicle is a "Flatbed" or "DFT-30"
					ProductList = Product_GetList(PCV_TruckerNoTrailer, NumProducts); // Build a list of products defined for truckers without a trailer
				case VehicleCementTruck: // If the player's vehicle is a "CementTruck"
					ProductList = Product_GetList(PCV_TruckerCementTruck, NumProducts); // Build a list of products defined for truckers witha cement truck
				case VehicleLineRunner, VehicleTanker, VehicleRoadTrain: // If the player's vehicle is a "LineRunner", "Tanker" or "RoadTrain"
				{
					switch (GetVehicleModel(GetVehicleTrailer(GetPlayerVehicleID(playerid)))) // Select the loads based on the trailer model of the player
					{
						case VehicleTrailerCargo, VehicleTrailerCargo2: // A cargo-trailer is attached
							ProductList = Product_GetList(PCV_TruckerCargoTrailer, NumProducts); // Build a list of products defined for truckers with a cargo-trailer
						case VehicleTrailerOre: // An Ore-trailer is attached
							ProductList = Product_GetList(PCV_TruckerOreTrailer, NumProducts); // Build a list of products defined for truckers with an ore-trailer
						case VehicleTrailerFluids: // A fluids-trailer is attached
							ProductList = Product_GetList(PCV_TruckerFluidsTrailer, NumProducts); // Build a list of products defined for truckers with a fluids-trailer
					}
				}
			}

			// Build the List with product-names
			for (new i; i < NumProducts; i++)
				format(TotalLoadList, 1000, "%s%s\n", TotalLoadList, ALoads[ProductList[i]][LoadName]);

			// Let the player choose a load
 			ShowPlayerDialog(playerid, DialogTruckerSelectLoad, DIALOG_STYLE_LIST, TXT_TruckerDialogSelectLoad, TotalLoadList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
		}

		case 1: Trucker_StartRandomJob(playerid); // Start a random trucker-job
	}

	return 1;
}
Dialog_TruckerSelectLoad(playerid, response, listitem)
{
    // Setup local variables
	new TotalStartLocList[1000], ProductList[50], NumProducts, ProductID, LocID;

	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// First get the list of products again, so we can retrieve the selected load from it
	switch (GetVehicleModel(GetPlayerVehicleID(playerid))) // Check the vehicle-model of the player
	{
		case VehicleFlatbed, VehicleDFT30: // If the player's vehicle is a "Flatbed" or "DFT-30"
			ProductList = Product_GetList(PCV_TruckerNoTrailer, NumProducts); // Build a list of products defined for truckers without a trailer
		case VehicleCementTruck: // If the player's vehicle is a "CementTruck"
			ProductList = Product_GetList(PCV_TruckerCementTruck, NumProducts); // Build a list of products defined for truckers witha cement truck
		case VehicleLineRunner, VehicleTanker, VehicleRoadTrain: // If the player's vehicle is a "LineRunner", "Tanker" or "RoadTrain"
		{
			switch (GetVehicleModel(GetVehicleTrailer(GetPlayerVehicleID(playerid)))) // Select the loads based on the trailer model of the player
			{
				case VehicleTrailerCargo, VehicleTrailerCargo2: // A cargo-trailer is attached
					ProductList = Product_GetList(PCV_TruckerCargoTrailer, NumProducts); // Build a list of products defined for truckers with a cargo-trailer
				case VehicleTrailerOre: // An Ore-trailer is attached
					ProductList = Product_GetList(PCV_TruckerOreTrailer, NumProducts); // Build a list of products defined for truckers with an ore-trailer
				case VehicleTrailerFluids: // A fluids-trailer is attached
					ProductList = Product_GetList(PCV_TruckerFluidsTrailer, NumProducts); // Build a list of products defined for truckers with a fluids-trailer
			}
		}
	}

	// Store the selected LoadID in the player's account
	APlayerData[playerid][LoadID] = ProductList[listitem];
	ProductID = APlayerData[playerid][LoadID];

	// Build a list of start-locations for this product
	for (new i; i < 30; i++)
	{
	    // Get the location-id
	    LocID = ALoads[ProductID][FromLocations][i];
	    // Check if it a valid location-id (not 0)
	    if (LocID != 0)
			format(TotalStartLocList, 1000, "%s%s\n", TotalStartLocList, ALocations[LocID][LocationName]); // Add the location-name to the list
		else
		    break; // As soon as an invalid location-id has been found, stop adding entries to the location-list
	}

	// Ask the player to choose a start-location
	ShowPlayerDialog(playerid, DialogTruckerStartLoc, DIALOG_STYLE_LIST, TXT_TruckerDialogSelectStartLoc, TotalStartLocList, TXT_DialogButtonSelect, TXT_DialogButtonCancel); // Let the player choose a starting location

	return 1;
}



// Process the selected startlocation and create the endlocation-dialog
Dialog_TruckerSelectStartLoc(playerid, response, listitem)
{
    // Setup local variables
	new ProductID, LocID, TotalEndLocList[1000];

	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the LoadID that's stored in the player's account
	ProductID = APlayerData[playerid][LoadID];
	// Store the chosen start-location in the player's account
	APlayerData[playerid][JobLoc1] = ALoads[ProductID][FromLocations][listitem];

	// Build a list of end-locations for this product
	for (new i; i < 30; i++)
	{
	    // Get the location-id
	    LocID = ALoads[ProductID][ToLocations][i];
	    // Check if it a valid location-id (not 0)
	    if (LocID != 0)
			format(TotalEndLocList, 1000, "%s%s\n", TotalEndLocList, ALocations[LocID][LocationName]); // Add the location-name to the list
		else
		    break; // As soon as an invalid location-id has been found, stop adding entries to the location-list
	}

	// Ask the player to choose an end-location
	ShowPlayerDialog(playerid, DialogTruckerEndLoc, DIALOG_STYLE_LIST, TXT_TruckerDialogSelectEndLoc, TotalEndLocList, TXT_DialogButtonSelect, TXT_DialogButtonCancel); // Let the player choose a endlocation

	return 1;
}



// Process the selected endlocation and start the job
Dialog_TruckerSelectEndLoc(playerid, response, listitem)
{
    // Setup local variables
	new RouteText[128], loadName[50], startlocName[50], endlocName[50], LoadMsg[128], Float:x, Float:y, Float:z, ProductID;

	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the LoadID that's stored in the player's account
	ProductID = APlayerData[playerid][LoadID];
	// Store the chosen end-location in the player's account
	APlayerData[playerid][JobLoc2] = ALoads[ProductID][ToLocations][listitem];

    // Get the names for the load, startlocation and endlocation
	format(loadName, 50, "%s", ALoads[ProductID][LoadName]);
	format(startlocName, 50, "%s", ALocations[APlayerData[playerid][JobLoc1]][LocationName]);
	format(endlocName, 50, "%s", ALocations[APlayerData[playerid][JobLoc2]][LocationName]);

	// Job has started
	APlayerData[playerid][JobStarted] = true;
	// Store the vehicleID (required to be able to check if the player left his vehicle)
	APlayerData[playerid][VehicleID] = GetPlayerVehicleID(playerid);
	// Store the trailerID (required to be able to check if the player lost his trailer)
	APlayerData[playerid][TrailerID] = GetVehicleTrailer(GetPlayerVehicleID(playerid));
	// Set jobstep to 1 (going to load the goods)
	APlayerData[playerid][JobStep] = 1;
	// Combine all data into a string for the TextDraw (the player can see this all the time) to describe the mission
	format(RouteText, 255, TXT_HaulingCargoFromToPickup, loadName, startlocName, endlocName);
	// Set the TextDraw so the player can see it
	TextDrawSetString(APlayerData[playerid][MissionText], RouteText);
	// Grab the x, y, z positions for the first location
	x = ALocations[APlayerData[playerid][JobLoc1]][LocX];
	y = ALocations[APlayerData[playerid][JobLoc1]][LocY];
	z = ALocations[APlayerData[playerid][JobLoc1]][LocZ];
	// Create a checkpoint where the player should load the goods
	SetPlayerCheckpoint(playerid, x, y, z, 7);
	// Set the job-fail-time for the global vehicle-timer
	APlayerData[playerid][VehicleTimerTime] = Job_TimeToFailMission;
	// Inform the player that he must load his goods
	format(LoadMsg, 128, TXT_PickupCargoAt, loadName, startlocName);
	SendClientMessage(playerid, 0xFFFFFFFF, LoadMsg);

	return 1;
}



// Process the work dialog for licensed busdrivers (show the list of busroutes after the player selected to choose his own route)
Dialog_BusSelectJobMethod(playerid, response, listitem)
{
	// Setup local variables
	new BusLine, Description[100], TotalRouteList[500];

	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

    // Check if the player already started a job
	if (APlayerData[playerid][JobStarted] == false)
	{
		// Select what to do after the player chose "Choose your own busroute" or "Auto assigned busroute"
		switch (listitem)
		{
			case 0: // Let the player choose his own busroute
			{
				// Construct the list of busroutes
				for (new i; i < sizeof(ABusRoutes); i++)
				{
					// Get the data about the route
					BusLine = ABusRoutes[i][LineNumber];
					format(Description, 100, ABusRoutes[i][RouteDescription]);
					// Add the busline to the list
					format(TotalRouteList, 500, "%s%sLinha %i (%s)", TotalRouteList, "\n", BusLine, Description);
				}

				// Let the player choose a busroute
 				ShowPlayerDialog(playerid, DialogBusSelectRoute, DIALOG_STYLE_LIST, TXT_SelectBusRoute, TotalRouteList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
			}

			case 1: BusDriver_StartJob(playerid, random(sizeof(ABusRoutes))); // Start a random job
		}
	}
	else // Send a message to let the player know he already has a job
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusdriverAlreadyDoingJob);

	return 1;
}

// Process the work dialog for licensed busdrivers (let the player start the job he selects from the busroute-list)
Dialog_BusSelectRoute(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// The selected listitem is automatically the busroute, so start the job based on the item selected in the busroute-list
	BusDriver_StartJob(playerid, listitem);

	return 1;
}



// Process the chosen quantity for courier job
Dialog_CourierSelectQuant(playerid, response, listitem)
{
	if(!response) return 1;
	switch (listitem)
	{
		case 0: APlayerData[playerid][CourierMaxStep] = 2;
		case 1: APlayerData[playerid][CourierMaxStep] = 5;
		case 2: APlayerData[playerid][CourierMaxStep] = 10;
	}
	Courier_BeginJob(playerid);
	return 1;
}



// Process the bike dialog
Dialog_Bike(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new Float:x, Float:y, Float:z, Float:rot, CarID, msg[120], vID, pName[24];
	new engine,lights,alarm,doors,bonnet,boot,objective;

	// Get the player's position and name
	GetPlayerPos(playerid, x, y, z);
	GetPlayerFacingAngle(playerid, rot);
	GetPlayerName(playerid, pName, 24);

	// Spawn the motorcycle based on the selection in the list, and spawn it 5 units north of the player
	switch (listitem)
	{
		case 0: CarID = VehicleBike; // Bike
		case 1: CarID = VehicleBMX; // BMX
		case 2: CarID = VehicleMountainBike; // Mountain Bike
		case 3: CarID = VehicleFaggio; // Faggio
		case 4: CarID = VehiclePizzaBoy; // Pizzaboy
		case 5: CarID = VehicleBF400; // BF-400
		case 6: CarID = VehicleNRG500; // NRG-500
		case 7: CarID = VehiclePCJ600; // PCJ-600
		case 8: CarID = VehicleFCR900; // FCR-900
		case 9: CarID = VehicleFreeway; // Freeway
		case 10: CarID = VehicleWayfarer; // Wayfarer
		case 11: CarID = VehicleSanchez; // Sanchez
		case 12: CarID = VehicleQuad; // Quad
	}
	vID = Vehicle_Create(CarID, x, y, z, rot, random(126), random(126), 600);
	// Put the player in the vehicle
	PutPlayerInVehicle(playerid, vID, 0);
	// Turn on the engine and lights
	GetVehicleParamsEx(vID, engine, lights, alarm, doors, bonnet, boot, objective);
	SetVehicleParamsEx(vID, 1, 1, alarm, doors, bonnet, boot, objective);
	// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
	GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
	APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
	// Inform all players about it
	format(msg, 120, TXT_PlayerSpawnedVehicle, pName, vID, CarID, x, y, z);
	SendClientMessageToAll(0xFFFFFFFF, msg);

	return 1;
}



// Process the car dialog
Dialog_Car(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response)
	{
		// Reset the FirstCar (so the list won't start at an unexpected location in the list, but back at the start of the list)
		APlayerData[playerid][DialogCarFirstCar] = 0;
		return 1; // Exit the function
	}

	// Process the selected listitem
	switch (listitem)
	{
		case 10: // Player chooses the empty line between the carlist and "Next...", so refresh the current list
		{
		    // Refresh the current list of cars and let the player choose one (show dialog)
		    CarList_Create(playerid);
			// Exit the function
			return 1;
		}
		case 11: // Player chooses "Next..."
		{
		    // Add 10 to the FirstCar, so the list will start further down the array (will show the next 10 cars)
		    APlayerData[playerid][DialogCarFirstCar] = APlayerData[playerid][DialogCarFirstCar] + 10;
		    // Create a new list of cars and show the dialog
		    CarList_Create(playerid);
		}
		default: // Player chooses a car
		{
		    // Setup local variables
	    	new Float:x, Float:y, Float:z, Float:rot, CarIndex, msg[128], vID, pName[24];
			new engine,lights,alarm,doors,bonnet,boot,objective;

			// FirstCar is the index of the first car in the list, so select the proper index when a car is chosen by the player
			CarIndex = APlayerData[playerid][DialogCarFirstCar] + listitem;
			GetPlayerPos(playerid, x, y, z);
			GetPlayerFacingAngle(playerid, rot);
			GetPlayerName(playerid, pName, 24);
			vID = Vehicle_Create(ACars[CarIndex][CarModel], x, y, z, rot, random(126), random(126), 600);
			// Put the player in the vehicle
			PutPlayerInVehicle(playerid, vID, 0);
			// Turn on the engine and lights
			GetVehicleParamsEx(vID, engine, lights, alarm, doors, bonnet, boot, objective);
			SetVehicleParamsEx(vID, 1, 1, alarm, doors, bonnet, boot, objective);
			// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
			GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
			APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
			// Inform all players about it
			format(msg, 120, TXT_PlayerSpawnedVehicle, pName, vID, ACars[CarIndex][CarModel], x, y, z);
			SendClientMessageToAll(0xFFFFFFFF, msg);
			// Also, after spawning a vehicle, reset FirstCar (so next time, the list starts from the start)
			APlayerData[playerid][DialogCarFirstCar] = 0;
		}
	}

	return 1;
}



// Process the Plane dialog
Dialog_Plane(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response)
	{
		// Reset the FirstPlane (so the list won't start at an unexpected location in the list, but back at the start of the list)
		APlayerData[playerid][DialogPlaneFirstPlane] = 0;
		return 1; // Exit the function
	}

	// Process the selected listitem
	switch (listitem)
	{
		case 10: // Player chooses the empty line between the Planelist and "Next...", so refresh the current list
		{
		    // Refresh the current list of Planes and let the player choose one (show dialog)
		    PlaneList_Create(playerid);
			// Exit the function
			return 1;
		}
		case 11: // Player chooses "Next..."
		{
		    // Add 10 to the FirstPlane, so the list will start further down the array (will show the next 10 Planes)
		    APlayerData[playerid][DialogPlaneFirstPlane] = APlayerData[playerid][DialogPlaneFirstPlane] + 10;
		    // Create a new list of Planes and show the dialog
		    PlaneList_Create(playerid);
		}
		default: // Player chooses a Plane
		{
		    // Setup local variables
	    	new Float:x, Float:y, Float:z, Float:rot, PlaneIndex, msg[128], vID, pName[24];
			new engine,lights,alarm,doors,bonnet,boot,objective;

			// FirstPlane is the index of the first Plane in the list, so select the proper index when a Plane is chosen by the player
			PlaneIndex = APlayerData[playerid][DialogPlaneFirstPlane] + listitem;

			// Get the player's position and name
			GetPlayerPos(playerid, x, y, z);
			GetPlayerFacingAngle(playerid, rot);
			GetPlayerName(playerid, pName, 24);
			vID = Vehicle_Create(APlanes[PlaneIndex][PlaneModel], x, y, z, rot, random(126), random(126), 600);
			// Put the player in the vehicle
			PutPlayerInVehicle(playerid, vID, 0);
			// Turn on the engine and lights
			GetVehicleParamsEx(vID, engine, lights, alarm, doors, bonnet, boot, objective);
			SetVehicleParamsEx(vID, 1, 1, alarm, doors, bonnet, boot, objective);
			// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
			GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
			APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
			// Inform the player about it
			format(msg, 128, TXT_PlayerSpawnedVehicle, pName, vID, APlanes[PlaneIndex][PlaneModel], x, y, z);
			SendClientMessageToAll(0xFFFFFFFF, msg);
			// Also, after spawning a vehicle, reset FirstPlane (so next time, the list starts from the start)
			APlayerData[playerid][DialogPlaneFirstPlane] = 0;
		}
	}

	return 1;
}



// Process the Trailer dialog
Dialog_Trailer(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response)
	{
		// Reset the FirstTrailer (so the list won't start at an unexpected location in the list, but back at the start of the list)
		APlayerData[playerid][DialogTrailerFirstTrailer] = 0;
		return 1; // Exit the function
	}

	// Process the selected listitem
	switch (listitem)
	{
		case 10: // Player chooses the empty line between the Trailerlist and "Next...", so refresh the current list
		{
		    // Refresh the current list of Trailers and let the player choose one (show dialog)
		    TrailerList_Create(playerid);
			// Exit the function
			return 1;
		}
		case 11: // Player chooses "Next..."
		{
		    // Add 10 to the FirstTrailer, so the list will start further down the array (will show the next 10 Trailers)
		    APlayerData[playerid][DialogTrailerFirstTrailer] = APlayerData[playerid][DialogTrailerFirstTrailer] + 10;
		    // Create a new list of Trailers and show the dialog
		    TrailerList_Create(playerid);
		}
		default: // Player chooses a Trailer
		{
		    // Setup local variables
	    	new Float:x, Float:y, Float:z, TrailerIndex, msg[128], vID, pName[24];

			// FirstTrailer is the index of the first Trailer in the list, so select the proper index when a Trailer is chosen by the player
			TrailerIndex = APlayerData[playerid][DialogTrailerFirstTrailer] + listitem;

			// Get the player's position and name
			GetPlayerPos(playerid, x, y, z);
			GetPlayerName(playerid, pName, 24);
			vID = Vehicle_Create(ATrailers[TrailerIndex][TrailerModel], x, y + 10.0, z + 5.0, 0.0, random(126), random(126), 600);
			// Inform the player about it
			format(msg, 128, TXT_PlayerSpawnedVehicle, pName, vID, ATrailers[TrailerIndex][TrailerModel], x, y + 10.0, z + 5.0);
			SendClientMessageToAll(0xFFFFFFFF, msg);
			// Also, after spawning a vehicle, reset FirstTrailer (so next time, the list starts from the start)
			APlayerData[playerid][DialogTrailerFirstTrailer] = 0;
		}
	}

	return 1;
}



// Process the boat dialog
Dialog_Boat(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new Float:x, Float:y, Float:z, Float:rot, CarID, msg[120], vID, pName[24];
	new engine,lights,alarm,doors,bonnet,boot,objective;

	// Get the player's position and name
	GetPlayerPos(playerid, x, y, z);
	GetPlayerFacingAngle(playerid, rot);
	GetPlayerName(playerid, pName, 24);

	// Spawn the boat based on the selection in the list
	switch (listitem)
	{
		case 0: CarID = VehicleCoastguard; // Coastguard
		case 1: CarID = VehicleDinghy; // Dinghy
		case 2: CarID = VehicleJetmax; // Jetmax
		case 3: CarID = VehicleLaunch; // Launch
		case 4: CarID = VehicleMarquis; // Marquis
		case 5: CarID = VehiclePredator; // Predator
		case 6: CarID = VehicleReefer; // Reefer
		case 7: CarID = VehicleSpeeder; // Speeder
		case 8: CarID = VehicleSquallo; // Squallo
		case 9: CarID = VehicleTropic; // Tropic
	}
	vID = Vehicle_Create(CarID, x, y, z, rot, random(126), random(126), 600);
	// Put the player in the vehicle
	PutPlayerInVehicle(playerid, vID, 0);
	// Turn on the engine and lights
	GetVehicleParamsEx(vID, engine, lights, alarm, doors, bonnet, boot, objective);
	SetVehicleParamsEx(vID, 1, 1, alarm, doors, bonnet, boot, objective);
	// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
	GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
	APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
	// Inform all players about it
	format(msg, 120, TXT_PlayerSpawnedVehicle, pName, vID, CarID, x, y, z);
	SendClientMessageToAll(0xFFFFFFFF, msg);

	return 1;
}



// Process the neon dialog
Dialog_Neon(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new vehicleid;

	// Get the player's vehicle
	vehicleid = GetPlayerVehicleID(playerid);

	// Check if the player chose anothet option than "Remove neons"
	if (listitem != 7)
	{
		// Check if the vehicle already has neon lights attached
	    if (AVehicleData[vehicleid][NeonLeft] != 0)
	    {
	        // Delete the current neon-lights and clear the variables
            DestroyObject(AVehicleData[vehicleid][NeonLeft]);
            DestroyObject(AVehicleData[vehicleid][NeonRight]);
            AVehicleData[vehicleid][NeonLeft] = 0;
            AVehicleData[vehicleid][NeonRight] = 0;
	    }
	}

	// Process the option chosen from the dialog
	if (listitem == 0) // Police Light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18646,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18646,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Sirenes adicionadas.", 3500, 5);
	}

	if (listitem == 1) // Red light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18647,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18647,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon ~r~vermelho~w~ adicionado.", 3500, 5);
	}

	if (listitem == 2) // Blue light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18648,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18648,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon ~b~azul~w~ adicionado.", 3500, 5);
	}

	if (listitem == 3) // Green Light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18649,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18649,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon ~g~verde~w~ adicionado.", 3500, 5);
	}

	if (listitem == 4) // Yellow Light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18650,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18650,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon ~y~amarelo~w~ adicionado.", 3500, 5);
	}

	if (listitem == 5) // Pink Light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18651,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18651,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon ~p~rosa~w~ adicionado.", 3500, 5);
	}

	if (listitem == 6) // White Light
	{
	    AVehicleData[vehicleid][NeonLeft] = CreateObject(18652,0,0,0,0,0,0);
	    AVehicleData[vehicleid][NeonRight] = CreateObject(18652,0,0,0,0,0,0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonLeft], vehicleid, -0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		AttachObjectToVehicle(AVehicleData[vehicleid][NeonRight], vehicleid, 0.8, 0.0, -0.70, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "Neon branco adicionado.", 3500, 5);
	}

	if (listitem == 7) // Remove neons
	{
        // Delete the current neon-lights and clear the variables
        DestroyObject(AVehicleData[vehicleid][NeonLeft]);
        DestroyObject(AVehicleData[vehicleid][NeonRight]);
        AVehicleData[vehicleid][NeonLeft] = 0;
        AVehicleData[vehicleid][NeonRight] = 0;
		GameTextForPlayer(playerid, "Neon ~r~removido.", 3500, 5);
	}

	return 1;
}



// Process the chosen vehicleclass to show the actual vehicle-list of this vehicleclass
Dialog_RentProcessClass(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new CarList[1000], DialogTitle[128];

	// Set the player's chosen vehicle-class based on the listitem he chose (add 1 as the vehicleclass starts at 1)
	APlayerData[playerid][DialogRentVClass] = listitem + 1;

	// Add all vehicles of the same class to the list
	for (new i; i < sizeof(ABuyableVehicles); i++)
	{
		// Check if the vehicle in the list has the same class as requested
		if (ABuyableVehicles[i][VehicleClass] == APlayerData[playerid][DialogRentVClass])
		{
			// Add the carname to the list and it's price
			format(CarList, 1000, "%s%s%s (R$%i)", CarList, "\n", ABuyableVehicles[i][CarName], ABuyableVehicles[i][Price] / 10); // Add the name of the next car to the list on the next line
		}
	}

	// Check if the list is empty
	if (strlen(CarList) == 0)
	{
		// Send the player a message that all vehicles have been disabled of the chosen class (no vehicles in the array of this class)
		SendClientMessage(playerid, 0xFFFFFFFF, TXT_BuyRentCarEmptyList);
		// Exit the function (don't ask to choose a vehicle)
		return 1;
	}

	// Set a title for the dialog based on the requested vehicleclass
	switch (APlayerData[playerid][DialogRentVClass])
	{
		case VClassBike: format(DialogTitle, 128, TXT_RentBike);
		case VClassBoat: format(DialogTitle, 128, TXT_RentBoat);
		case VClassConvertible: format(DialogTitle, 128, TXT_RentConvertible);
		case VClassHelicopter: format(DialogTitle, 128, TXT_RentHelicopter);
		case VClassIndustrial: format(DialogTitle, 128, TXT_RentIndustrial);
		case VClassLowRider: format(DialogTitle, 128, TXT_RentLowRider);
		case VClassOffRoad: format(DialogTitle, 128, TXT_RentOffRoad);
		case VClassPlane: format(DialogTitle, 128, TXT_RentPlane);
		case VClassPublic: format(DialogTitle, 128, TXT_RentPublicService);
		case VClassRCVehicle: format(DialogTitle, 128, TXT_RentRC);
		case VClassSaloons: format(DialogTitle, 128, TXT_RentSaloon);
		case VClassSportCar: format(DialogTitle, 128, TXT_RentSport);
		case VClassStationCar: format(DialogTitle, 128, TXT_RentStationWagon);
		case VClassTrailer: format(DialogTitle, 128, TXT_RentTrailer);
		case VClassUnique: format(DialogTitle, 128, TXT_RentUnique);
	}

	// Ask which car the player wants to have by showing the dialog
	ShowPlayerDialog(playerid, DialogRentCar, DIALOG_STYLE_LIST, DialogTitle, CarList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);

	return 1;
}



// This dialog gives the chosen vehicle to the player (bought or rented)
Dialog_RentCar(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new Counter, Name[24], Float:x, Float:y, Float:z, Msg[128];

	// Loop through the entire list of buyable vehicles
	for (new i; i < sizeof(ABuyableVehicles); i++)
	{
		// Check if the vehicle in the list has the same class as requested
		if (ABuyableVehicles[i][VehicleClass] == APlayerData[playerid][DialogRentVClass])
		{
		    // Check if this is the vehicle that the player chose
		    if (Counter == listitem)
			{
			    // Check if the player has enough money to afford renting this vehicle
			    if (APlayerData[playerid][PlayerMoney] >= (ABuyableVehicles[i][Price] / 10))
			    {
					// Check if the player already has a rented vehicle
					if (APlayerData[playerid][RentedVehicleID] != 0)
					{
						// Clear the data for the already rented vehicle
						AVehicleData[APlayerData[playerid][RentedVehicleID]][Model] = 0;
						AVehicleData[APlayerData[playerid][RentedVehicleID]][Fuel] = 0;
						AVehicleData[APlayerData[playerid][RentedVehicleID]][Owned] = false;
						AVehicleData[APlayerData[playerid][RentedVehicleID]][Owner] = 0;
						AVehicleData[APlayerData[playerid][RentedVehicleID]][PaintJob] = 0;
						for (new j; j < 14; j++)
						{
							AVehicleData[APlayerData[playerid][RentedVehicleID]][Components][j] = 0;
						}
						// Destroy the vehicle
						DestroyVehicle(APlayerData[playerid][RentedVehicleID]);
						// Send the player a message that his previously rented vehicle has been replaced by the new one
						SendClientMessage(playerid, 0xFFFFFFFF, TXT_AlreadyRentedVehicle);
					}

					// Create the vehicle and link it to the player's account
					GetPlayerPos(playerid, x, y, z);
				    APlayerData[playerid][RentedVehicleID] = CreateVehicle(ABuyableVehicles[i][CarModel], x, y, z, 0.0, -1, -1, 600);
					// Also set owndership data
					AVehicleData[APlayerData[playerid][RentedVehicleID]][Model] = ABuyableVehicles[i][CarModel];
					AVehicleData[APlayerData[playerid][RentedVehicleID]][Fuel] = MaxFuel;
					AVehicleData[APlayerData[playerid][RentedVehicleID]][Owned] = true;
					GetPlayerName(playerid, Name, sizeof(Name));
					format(AVehicleData[APlayerData[playerid][RentedVehicleID]][Owner], 24, Name);
					// Put the player in the vehicle
					PutPlayerInVehicle(playerid, APlayerData[playerid][RentedVehicleID], 0);
					// Turn on the engine
					new engine,lights,alarm,doors,bonnet,boot,objective;
					GetVehicleParamsEx(APlayerData[playerid][RentedVehicleID], engine, lights, alarm, doors, bonnet, boot, objective);
					SetVehicleParamsEx(APlayerData[playerid][RentedVehicleID], 1, lights, alarm, doors, bonnet, boot, objective);
					// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
					GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
					APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
					// Let the player pay for renting the vehicle
					APlayerData[playerid][PlayerMoney] = APlayerData[playerid][PlayerMoney] - (ABuyableVehicles[i][Price] / 10);
					// Let the player know he rented a vehicle
					format(Msg, 128, TXT_PlayerRentsVehicle, ABuyableVehicles[i][CarName], (ABuyableVehicles[i][Price] / 10));
					SendClientMessage(playerid, 0xFFFFFFFF, Msg);
				}
				else // The player has not enough money to rent this vehicle
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_RentingTooExpensive);

				// Stop looking for the vehicle, as it's found and given to the player already
				return 1;
			}
		    else // The player chose another vehicle from the same class, keep looking for another one
		        Counter++;
		}
	}

	return 1;
}



// Process the weather dialog
Dialog_Weather(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new WeatherID;

	// Select the weather
	switch (listitem)
	{
		case 0: WeatherID = 0; // Normal
		case 1: WeatherID = 8; // Stormy
		case 2: WeatherID = 9; // Foggy
		case 3: WeatherID = 11; // Scorching hot
		case 4: WeatherID = 16; // Dull, cloudy, rainy
		case 5: WeatherID = 19; // Sandstorm
		case 6: WeatherID = 20; // Green Fog
		case 7: WeatherID = 33; // Dark, cloudy, brown
		case 8: WeatherID = 39; // Extremely bright
		case 9: WeatherID = 43; // Dark toxic clouds
		case 10: WeatherID = 44; // Black & white sky
	}

	// Set the weather
    SetWeather(WeatherID);
    // Inform the player about it
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_ChangedWeather;

	return 1;
}

// Process the caroption dialog
Dialog_CarOption(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

    // Setup local variables
	new vehicleid, engine, lights, bool:alarm, bool:doors, bool:bonnet, bool:boot, bool:objective;

	// Get the player's vehicle
	vehicleid = GetPlayerVehicleID(playerid);

	// Get the current status of the vehicle
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);

	// Select the weather
	switch (listitem)
	{
		case 0: SetVehicleParamsEx(vehicleid, 1 - engine, lights, alarm, doors, bonnet, boot, objective);
		case 1: SetVehicleParamsEx(vehicleid, engine, 1 - lights, alarm, doors, bonnet, boot, objective);
		case 2:
		{
			if (alarm == true)
				SetVehicleParamsEx(vehicleid, engine, lights, false, doors, bonnet, boot, objective);
			else
				SetVehicleParamsEx(vehicleid, engine, lights, true, doors, bonnet, boot, objective);
		}
		case 3:
		{
			if (doors == true)
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, false, bonnet, boot, objective);
			else
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, true, bonnet, boot, objective);
		}
		case 4:
		{
			if (bonnet == true)
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, false, boot, objective);
			else
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, true, boot, objective);
		}
		case 5:
		{
			if (boot == true)
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, false, objective);
			else
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, true, objective);
		}
		case 6:
		{
			if (objective == true)
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, false);
			else
				SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, true);
		}
	}

	return 1;
}



// This function processes the convoy dialog
Dialog_SelectConvoy(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new Convoy;

	// The convoy-id is automatically the listitem
	Convoy = listitem;

	// Check the status of the selected convoy to determine what to do
	switch (AConvoys[Convoy][Status])
	{
	    case CONVOY_EMPTY: // Convoy isn't started yet, this is a free convoy
		{
			Convoy_Create(playerid, Convoy); // Try to create the convoy
		}
	    case CONVOY_OPEN: // Convoy has been created but still open for new members to join
		{
		    Convoy_Join(playerid, Convoy); // Try to join the convoy
		}
	    case CONVOY_FULL: // Convoy is full (10 members)
		{
			SendClientMessage(playerid, 0xFFFFFFFF, TXT_ConvoyFull);
		}
	    case CONVOY_CLOSED: // Convoy has started already (the leader already chose a job, causing the convoy to close)
		{
			SendClientMessage(playerid, 0xFFFFFFFF, TXT_ConvoyEnRoute);
		}
	}

	return 1;
}

// This function processes the housemenu dialog
Dialog_HouseMenu(playerid, response, listitem)
{
	if(!response) return 1;
	new UpgradeList[2000], HouseID, DialogTitle[200], Counter, UpgradePrice, Msg[128], CarSlot, VehicleClassList[1000], VehicleList[500];
	HouseID = APlayerData[playerid][CurrentHouse];
	switch(listitem)
	{
	    case 0: 
	    {
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
		        format(DialogTitle, 200, TXT_DialogOldHouseName, AHouseData[HouseID][HouseName]);
				ShowPlayerDialog(playerid, DialogHouseNameChange, DIALOG_STYLE_INPUT, DialogTitle, TXT_DialogEnterNewHouseName, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
	    }
	    case 1: // Upgrade the house
	    {
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
		        // Check if it's possible to upgrade further
				if (AHouseData[HouseID][HouseLevel] < AHouseData[HouseID][HouseMaxLevel])
				{
					// Add only the upgrades above the current house-level to the upgradelist
					for (new i = AHouseData[HouseID][HouseLevel] + 1; i <= AHouseData[HouseID][HouseMaxLevel]; i++)
					{
					    Counter++; // Add 1 to the counter each time an upgrade is added to the upgradelist
					    UpgradePrice = ((AHouseData[HouseID][HousePrice] * Counter) / 100) * HouseUpgradePercent;
					    // Add the upgrade-info in green if the player can afford it, and in red if he cannot afford it
						if (APlayerData[playerid][PlayerMoney] >= UpgradePrice)
							format(UpgradeList, 2000, "%s{00FF00}%s (level %i)\t\tR$%i\n", UpgradeList, AHouseInteriors[i][InteriorName], i, UpgradePrice);
						else
							format(UpgradeList, 2000, "%s{FF0000}%s (level %i)\t\tR$%i\n", UpgradeList, AHouseInteriors[i][InteriorName], i, UpgradePrice);
					}

			        // Show another dialog to let the player select which upgrade he wants for his house
					ShowPlayerDialog(playerid, DialogUpgradeHouse, DIALOG_STYLE_LIST, TXT_DialogSelectHouseUpgrade, UpgradeList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_HouseReachedMaxLevel);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
	    }
		case 2: // Buy house-car
		{
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
			    // Find a free carslot
			    CarSlot = House_GetFreeCarSlot(HouseID);
			    // Check if the carslot is valid
			    if (CarSlot != -1)
			    {
				    // Let the player choose a vehicle-class
					format(VehicleClassList, 1000, "%s{00FF00}%s{FFFFFF}\n", VehicleClassList, "Motos");
					format(VehicleClassList, 1000, "%s{40FF00}%s{FFFFFF}\n", VehicleClassList, "Barcos");
					format(VehicleClassList, 1000, "%s{80FF00}%s{FFFFFF}\n", VehicleClassList, "Converssíveis");
					format(VehicleClassList, 1000, "%s{B0FF00}%s{FFFFFF}\n", VehicleClassList, "Helicopteros");
					format(VehicleClassList, 1000, "%s{FFFF00}%s{FFFFFF}\n", VehicleClassList, "Veículos Industriais");
					format(VehicleClassList, 1000, "%s{B0FF40}%s{FFFFFF}\n", VehicleClassList, "Low-riders");
					format(VehicleClassList, 1000, "%s{80FF80}%s{FFFFFF}\n", VehicleClassList, "Veículos 4x4");
					format(VehicleClassList, 1000, "%s{40FFB0}%s{FFFFFF}\n", VehicleClassList, "Aviões");
					format(VehicleClassList, 1000, "%s{00FFFF}%s{FFFFFF}\n", VehicleClassList, "Veículos de Serviço Público");
					format(VehicleClassList, 1000, "%s{00B0FF}%s{FFFFFF}\n", VehicleClassList, "Veículos de Controle Remoto");
					format(VehicleClassList, 1000, "%s{0080FF}%s{FFFFFF}\n", VehicleClassList, "Veículos de Salão");
					format(VehicleClassList, 1000, "%s{0040FF}%s{FFFFFF}\n", VehicleClassList, "Veículos Sport");
					format(VehicleClassList, 1000, "%s{0000FF}%s{FFFFFF}\n", VehicleClassList, "Veículos Simples");
					format(VehicleClassList, 1000, "%s{4000FF}%s{FFFFFF}\n", VehicleClassList, "Trailers");
					format(VehicleClassList, 1000, "%s{8000FF}%s{FFFFFF}\n", VehicleClassList, "Veículos Únicos");
					ShowPlayerDialog(playerid, DialogBuyCarClass, DIALOG_STYLE_LIST, TXT_DialogBuyCarSelectClass, VehicleClassList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
			    }
			    else
			        SendClientMessage(playerid, 0xFFFFFFFF, TXT_HouseHasMaxVehicles);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
		}
		case 3: // Buy house-car insurance
		{
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
			    new MsgInsurance[128];
			    // Check if this house doesn't have insurance yet
			    if (AHouseData[HouseID][Insurance] == 0)
			    {
			        // Check if the player can afford the insurance
			        if (APlayerData[playerid][PlayerMoney] >= (AHouseData[HouseID][HousePrice] / 10))
			        {
					    // Construct the message for the dialog, this includes the price for the insurance
					    format(MsgInsurance, 128, TXT_DialogBuyInsurance, AHouseData[HouseID][HousePrice] / 10);
						// Ask the player if the wants to buy an insurance for this house's vehicles
						ShowPlayerDialog(playerid, DialogBuyInsurance, DIALOG_STYLE_MSGBOX, TXT_DialogTitleBuyInsurance, MsgInsurance, TXT_DialogButtonYes, TXT_DialogButtonNo);
					}
					else
					    SendClientMessage(playerid, 0xFFFFFFFF, TXT_CannotAffordInsurance);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_HouseAlreadyHasInsurance);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
		}
		case 4: // Sell house-car
		{
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
			    new BuyableCarIndex, bool:HouseHasCars = false;

				// Check if the house has any cars assigned to it
				for (CarSlot = 0; CarSlot < 5; CarSlot++)
				    if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
				        HouseHasCars = true;

				// Check if the house has any cars assigned to it
				if (HouseHasCars == true)
				{
					// Add all vehicles to the list
					for (CarSlot = 0; CarSlot < 10; CarSlot++)
					{
						if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
						{
						    // Get the index where the first vehicle is found in the ABuyableVehicles array
						    BuyableCarIndex = VehicleBuyable_GetIndex(GetVehicleModel(AHouseData[HouseID][VehicleIDs][CarSlot]));
						    // Add the name of the vehicle to the list
						    format(VehicleList, 500, "%s{00FF00}%s: R$%i{FFFFFF}\n", VehicleList, ABuyableVehicles[BuyableCarIndex][CarName], ABuyableVehicles[BuyableCarIndex][Price] / 2);
						}
						else
							format(VehicleList, 500, TXT_EmptyCarSlot, VehicleList);
					}

					// Ask which vehicle class the player wants to see to buy a vehicle
					ShowPlayerDialog(playerid, DialogSellCar, DIALOG_STYLE_LIST, TXT_SelectVehicleToSell, VehicleList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoHouseVehicles);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
		}
		case 5: // Sell house
		{
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
			    // Setup local variables
			    new bool:HouseHasCars = false;

				// Check if the house has any cars assigned to it
				for (CarSlot = 0; CarSlot < 10; CarSlot++)
				    if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
				        HouseHasCars = true;

				// Check if all house-cars have been sold (all slots are empty)
				if (HouseHasCars == false)
				{
				    format(Msg, 128, TXT_SureSellHouse, House_CalcSellPrice(HouseID));
					ShowPlayerDialog(playerid, DialogSellHouse, DIALOG_STYLE_MSGBOX, TXT_AreYouSure, Msg, TXT_DialogButtonYes, TXT_DialogButtonNo);
				}
				else
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_CannotSellHouseWithCars);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
		}
	    case 6: // Open the house to the public (everyone can enter it)
	    {
			// Only the house-owner can use this option
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
			    // Open the house to the public
				AHouseData[HouseID][HouseOpened] = true;
				// Let the player know he opened the house to the public
				SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Casa aberta para o publico");
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
	    }
	    case 7: // Close the house to the public (only the owner can enter it)
	    {
			if (House_PlayerIsOwner(playerid, HouseID) == 1)
			{
				AHouseData[HouseID][HouseOpened] = false;
				SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Casa fechada para o publico");
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não está na sua casa.");
	    }
	    case 8: // Exit the house
	    {
			House_Exit(playerid, HouseID);
	    }
	}

	return 1;
}

// This function processes the house-upgrade menu
Dialog_UpgradeHouse(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the HouseID of the house where the player is
	new HouseID = APlayerData[playerid][CurrentHouse];
	// Calculate the new house-level based on the selection in the list (the first entry is 1 level higher than the current house-level)
	new hLevel = listitem + 1 + AHouseData[HouseID][HouseLevel];
	// Calculate the price for upgrading
	new Payment = ((AHouseData[HouseID][HousePrice] * (listitem + 1)) / 100) * HouseUpgradePercent;

	// Check if the player can afford it
	if (APlayerData[playerid][PlayerMoney] >= Payment)
	{
		// Upgrade the house
		AHouseData[HouseID][HouseLevel] = hLevel;
		// Set the worldid so other players cannot see him anymore
		SetPlayerVirtualWorld(playerid, 1000 + playerid);
		// Set the player inside the new interior of the house
		SetPlayerInterior(playerid, AHouseInteriors[hLevel][InteriorID]);
		// Set the position of the player at the spawn-location of the house's interior
		SetPlayerPos(playerid, AHouseInteriors[hLevel][IntX], AHouseInteriors[hLevel][IntY], AHouseInteriors[hLevel][IntZ]);

		// Let the player pay for the upgrade
		new Msg[128];
		RewardPlayer(playerid, -Payment, 0);
		format(Msg, 128, TXT_PlayerUpgradedHouse, AHouseData[HouseID][HouseLevel], Payment);
		SendClientMessage(playerid, 0xFFFFFFFF, Msg);

		// Also update the 3DText at the entrance of the house
		House_UpdateEntrance(APlayerData[playerid][CurrentHouse]);

		// Save the player-file (and his houses)
		PlayerFile_Save(playerid);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_CannotAffordUpgrade);

	return 1;
}



// Check which house the player chose, and port him to it
Dialog_GoHome(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new HouseIndex, HouseID;

	// The listitem directly indicates the house-index
	HouseIndex = listitem;
	HouseID = APlayerData[playerid][Houses][HouseIndex];

	// Check if this is a valid house (HouseID != 0)
	if (HouseID != 0)
	{
		// Get the coordinates of the house's entrance
		SetPlayerPos(playerid, AHouseData[HouseID][HouseX], AHouseData[HouseID][HouseY], AHouseData[HouseID][HouseZ]);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoHouseInSlot);

	return 1;
}

// Let the player change the name of his house
Dialog_ChangeHouseName(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel" or if the player didn't input any text
	if ((!response) || (strlen(inputtext) == 0)) return 1;

	// Change the name of the house
	format(AHouseData[APlayerData[playerid][CurrentHouse]][HouseName], 100, inputtext);
	// Also update the 3DText at the entrance of the house
	House_UpdateEntrance(APlayerData[playerid][CurrentHouse]);
	// Let the player know that the name of his house has been changed
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_ChangedHouseName);

	// Save the player-file (and his houses)
	PlayerFile_Save(playerid);

	return 1;
}

// Choose a vehicle class from which to buy a vehicle
Dialog_BuyCarClass(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new CarList[1000], DialogTitle[128];

	// Set the player's chosen vehicle-class based on the listitem he chose (add 1 as the vehicleclass starts at 1)
	APlayerData[playerid][DialogBuyVClass] = listitem + 1;

	// Add all vehicles of the same class to the list
	for (new i; i < sizeof(ABuyableVehicles); i++)
	{
		// Check if the vehicle in the list has the same class as requested
		if (ABuyableVehicles[i][VehicleClass] == APlayerData[playerid][DialogBuyVClass])
		{
			// Add the carname to the list and it's price
			format(CarList, 1000, "%s%s%s (R$%i)", CarList, "\n", ABuyableVehicles[i][CarName], ABuyableVehicles[i][Price]); // Add the name of the next car to the list on the next line
		}
	}

	// Check if the list is empty
	if (strlen(CarList) == 0)
	{
		// Send the player a message that all vehicles have been disabled of the chosen class (no vehicles in the array of this class)
		SendClientMessage(playerid, 0xFFFFFFFF, TXT_BuyRentCarEmptyList);
		// Exit the function (don't ask to choose a vehicle)
		return 1;
	}

	// Set a title for the dialog based on the requested vehicleclass
	switch (APlayerData[playerid][DialogBuyVClass])
	{
		case VClassBike: format(DialogTitle, 128, TXT_BuyBike);
		case VClassBoat: format(DialogTitle, 128, TXT_BuyBoat);
		case VClassConvertible: format(DialogTitle, 128, TXT_BuyConvertible);
		case VClassHelicopter: format(DialogTitle, 128, TXT_BuyHelicopter);
		case VClassIndustrial: format(DialogTitle, 128, TXT_BuyIndustrial);
		case VClassLowRider: format(DialogTitle, 128, TXT_BuyLowRider);
		case VClassOffRoad: format(DialogTitle, 128, TXT_BuyOffRoad);
		case VClassPlane: format(DialogTitle, 128, TXT_BuyPlane);
		case VClassPublic: format(DialogTitle, 128, TXT_BuyPublicService);
		case VClassRCVehicle: format(DialogTitle, 128, TXT_BuyRC);
		case VClassSaloons: format(DialogTitle, 128, TXT_BuySaloon);
		case VClassSportCar: format(DialogTitle, 128, TXT_BuySport);
		case VClassStationCar: format(DialogTitle, 128, TXT_BuyStationWagon);
		case VClassTrailer: format(DialogTitle, 128, TXT_BuyTrailer);
		case VClassUnique: format(DialogTitle, 128, TXT_BuyUnique);
	}

	// Ask which car the player wants to have by showing the dialog
	ShowPlayerDialog(playerid, DialogBuyCar, DIALOG_STYLE_LIST, DialogTitle, CarList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);

	return 1;
}

// Buy a vehicle and assign it to the house
Dialog_BuyCar(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new Counter, Msg[128], cComponents[14];

	// Get the HouseID
	new HouseID = APlayerData[playerid][CurrentHouse];

	// Loop through the entire list of buyable vehicles
	for (new i; i < sizeof(ABuyableVehicles); i++)
	{
		// Check if the vehicle in the list has the same class as requested
		if (ABuyableVehicles[i][VehicleClass] == APlayerData[playerid][DialogBuyVClass])
		{
		    // Check if this is the vehicle that the player chose
		    if (Counter == listitem)
			{
			    // Check if the player has enough money to afford buying this vehicle
			    if (APlayerData[playerid][PlayerMoney] >= (ABuyableVehicles[i][Price]))
			    {
					House_AddVehicle(HouseID, ABuyableVehicles[i][CarModel], 0, cComponents, 2585.0, 2829.0, 10.9, 0.0, -1, -1);

					// Let the player pay for buying the vehicle
					APlayerData[playerid][PlayerMoney] = APlayerData[playerid][PlayerMoney] - ABuyableVehicles[i][Price];
					// Let the player know he bought a vehicle
					format(Msg, 128, TXT_PlayerBoughtVehicle, ABuyableVehicles[i][CarName], ABuyableVehicles[i][Price]);
					SendClientMessage(playerid, 0xFFFFFFFF, Msg);
					SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerMustUseGetcarAndPark);

					// Save the player-file (and his houses)
					PlayerFile_Save(playerid);
				}
				else // The player has not enough money to buy this vehicle
				    SendClientMessage(playerid, 0xFFFFFFFF, TXT_CannotAffordVehicle);

				// Stop looking for the vehicle, as it's found and given to the player already
				return 1;
			}
		    else // The player chose another vehicle from the same class, keep looking for another one
		        Counter++;
		}
	}

	return 1;
}

// Buy insurance for the house's vehicles
Dialog_BuyInsurance(playerid, response)
{
	if(!response) return 1;
	new Msg[128];
	new HouseID = APlayerData[playerid][CurrentHouse];
	AHouseData[HouseID][Insurance] = 1;
	RewardPlayer(playerid, -(AHouseData[HouseID][HousePrice] / 10), 0);
	format(Msg, 128, TXT_PlayerBoughtInsurance, AHouseData[HouseID][HousePrice] / 10);
	SendClientMessage(playerid, 0xFFFFFFFF, Msg);
	PlayerFile_Save(playerid);
	HouseFile_Save(HouseID);
	return 1;
}
Dialog_SellHouse(playerid, response)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the HouseID where the player is right now
	new HouseID = APlayerData[playerid][CurrentHouse], Msg[128];

	// Set the player in the normal world again
	SetPlayerVirtualWorld(playerid, 0);
	SetPlayerInterior(playerid, 0);
	// Set the position of the player at the entrance of his house
	SetPlayerPos(playerid, AHouseData[HouseID][HouseX], AHouseData[HouseID][HouseY], AHouseData[HouseID][HouseZ]);

	// Also clear the tracking-variable to track in which house the player is
	APlayerData[playerid][CurrentHouse] = 0;

	// Clear the owner of the house
	AHouseData[HouseID][Owned] = false;
	AHouseData[HouseID][Owner] = 0;
	// Clear the house-name and house-level
	AHouseData[HouseID][HouseName] = 0;
	AHouseData[HouseID][HouseLevel] = 1;

	// Refund the player 50% of the worth of the house
	RewardPlayer(playerid, House_CalcSellPrice(HouseID), 0);
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerSoldHouse);
    format(Msg, 128, TXT_PlayerSellHouseTxT, House_CalcSellPrice(HouseID));
    GameTextForPlayer(playerid, Msg, 5000, 1);         
    PlayerPlaySound(playerid, 1149, 0.0, 0.0, 0.0);

	// Clear the house-id from the player
	for (new i; i < MAX_HOUSESPERPLAYER; i++)
	{
		// If the house-slot if found where the house was added to the player
		if (APlayerData[playerid][Houses][i] == HouseID)
		{
		    // Clear the house-id
		    APlayerData[playerid][Houses][i] = 0;
		    // Stop searching
		    break;
		}
	}

	// Update the 3DText near the house's entrance to show other players that it's for sale again
	House_UpdateEntrance(HouseID);

	// Save the player-file (and his houses)
	PlayerFile_Save(playerid);
	// Also save the sold house, otherwise the old ownership-data is still there
	HouseFile_Save(HouseID);

	return 1;
}



// Sell the house
Dialog_SellCar(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new HouseID = APlayerData[playerid][CurrentHouse];
	new vid = AHouseData[HouseID][VehicleIDs][listitem];

	// Check if there is a vehicle stored in this carslot
	if (vid != 0)
	{
		new BuyableCarIndex = VehicleBuyable_GetIndex(GetVehicleModel(vid));
		new Msg[128];

		// Destroy the vehicle and remove it from the house
		DestroyVehicle(vid);
		AHouseData[HouseID][VehicleIDs][listitem] = 0;
		// Also clear the data
		AVehicleData[vid][Owned] = false;
		AVehicleData[vid][Owner] = 0;
		AVehicleData[vid][Model] = 0;
		AVehicleData[vid][PaintJob] = 0;
		for (new i; i < 14; i++)
			AVehicleData[vid][Components][i] = 0;
		AVehicleData[vid][SpawnX] = 0.0;
		AVehicleData[vid][SpawnY] = 0.0;
		AVehicleData[vid][SpawnZ] = 0.0;
		AVehicleData[vid][SpawnRot] = 0.0;

		// Refund the player with 50% of the vehicle's buying price
		APlayerData[playerid][PlayerMoney] = APlayerData[playerid][PlayerMoney] + (ABuyableVehicles[BuyableCarIndex][Price] / 2);
		// Let the player know about it
		format(Msg, 128, TXT_PlayerSoldVehicle, ABuyableVehicles[BuyableCarIndex][CarName], ABuyableVehicles[BuyableCarIndex][Price] / 2);
		SendClientMessage(playerid, 0xFFFFFFFF, Msg);

		// Save the player-file (and his houses)
		PlayerFile_Save(playerid);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoVehicleInSlot);

	return 1;
}

// This dialog processes the selected house from which to get a vehicle using /getcar
Dialog_GetCarSelectHouse(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the houseid based on the chosen listitem
	new HouseID = APlayerData[playerid][Houses][listitem];

	// Check if it was a valid house
	if (HouseID != 0)
	{
		// Setup local variables
	    new BuyableCarIndex, VehicleList[500], bool:HouseHasCars = false, CarSlot;

		// Store the HouseID, otherwise the next dialog won't be able to get a car from the chosen house
		APlayerData[playerid][DialogGetCarHouseID] = HouseID;

		// Check if the house has any cars assigned to it
		for (CarSlot = 0; CarSlot < 10; CarSlot++)
			if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
			    HouseHasCars = true;

		// Check if the house has any cars assigned to it
		if (HouseHasCars == true)
		{
			// Add all vehicles to the list
			for (CarSlot = 0; CarSlot < 10; CarSlot++)
			{
				// Check if the carslot has a vehicle in it
				if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
				{
				    // Get the index where the first vehicle is found in the ABuyableVehicles array
				    BuyableCarIndex = VehicleBuyable_GetIndex(GetVehicleModel(AHouseData[HouseID][VehicleIDs][CarSlot]));
				    // Add the name of the vehicle to the list
					if (AVehicleData[AHouseData[HouseID][VehicleIDs][CarSlot]][Clamped] == true)
					    format(VehicleList, 500, "%s{00FF00}%s (apreendido)\n", VehicleList, ABuyableVehicles[BuyableCarIndex][CarName]);
					else
					    format(VehicleList, 500, "%s{00FF00}%s\n", VehicleList, ABuyableVehicles[BuyableCarIndex][CarName]);
				}
				else
					format(VehicleList, 500, TXT_EmptyCarSlot, VehicleList);
			}

			// Ask which vehicle the player wants to teleport to his location
			ShowPlayerDialog(playerid, DialogGetCarSelectCar, DIALOG_STYLE_LIST, TXT_SelectVehicleToGet, VehicleList, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
		}
		else
		    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoHouseVehicles);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoHouseInSlot);

	return 1;
}

// This dialog processes the chosen car and spawns it at the player's location
Dialog_GetCarSelectCar(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Get the HouseID from which to get the car
	new HouseID = APlayerData[playerid][DialogGetCarHouseID];

	// Get the vehicleid from the chosen listitem
	new vid = AHouseData[HouseID][VehicleIDs][listitem];

	// Check if it was a valid vehicleid
	if (vid != 0)
	{
		// Check if the vehicle is clamped
		if (AVehicleData[vid][Clamped] == false)
		{
			// Setup local variables
			new Float:x, Float:y, Float:z, Float:Angle;
			// Get the player's position
			GetPlayerPos(playerid, x, y, z);
			GetPlayerFacingAngle(playerid, Angle);
			// Port the vehicle to the player
			SetVehiclePos(vid, x, y, z);
			// Put the player inside the vehicle and rotate the vehicle to face where the player was facing
			PutPlayerInVehicle(playerid, vid, 0);
			SetVehicleZAngle(vid, Angle);
			// Turn on the engine and lights
			new engine,lights,alarm,doors,bonnet,boot,objective;
			GetVehicleParamsEx(vid, engine, lights, alarm, doors, bonnet, boot, objective);
			SetVehicleParamsEx(vid, 1, 1, alarm, doors, bonnet, boot, objective);
			// Store the player's current location and interior-id, otherwise anti-airbreak hack code could kick you
			GetPlayerPos(playerid, APlayerData[playerid][PreviousX], APlayerData[playerid][PreviousY], APlayerData[playerid][PreviousZ]);
			APlayerData[playerid][PreviousInt] = GetPlayerInterior(playerid);
			// Let the player know he should park the vehicle
			SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerMustUsePark);
		}
		else // Inform the player that this vehicle is clamped and how he can un-clamp it
		{
		    SendClientMessage(playerid, 0xFFFFFFFF, TXT_SpeedometerClampedVehicle);
		    SendClientMessage(playerid, 0xFFFFFFFF, TXT_SpeedometerClampedVehicle2);
		}
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoVehicleInSlot);

	return 1;
}



// This dialog processes the chosen business-type and creates the business
Dialog_CreateBusSelType(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

    // Setup some local variables
	new BusType, BusID, Float:x, Float:y, Float:z, Msg[128], bool:EmptySlotFound = false;

	// Get the player's position
	GetPlayerPos(playerid, x, y, z);

	// Get the business-type from the option the player chose
	BusType = listitem + 1;

	// Find a free business-id
	for (BusID = 1; BusID < MAX_BUSINESS; BusID++)
	{
		// Check if this business ID is free
		if (ABusinessData[BusID][BusinessType] == 0)
		{
			EmptySlotFound = true;
		    break; // Stop processing
		}
	}

	// Check if an empty slot has been found
	if (EmptySlotFound == false)
	{
		// If no empty slot was found, let the player know about it and exit the function
		SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Numero máximo de empresas atingido");
		return 1;
	}

	// Set some default data at the index of NextFreeBusinessID (NextFreeBusinessID will point to the next free business-index)
	ABusinessData[BusID][BusinessX] = x;
	ABusinessData[BusID][BusinessY] = y;
	ABusinessData[BusID][BusinessZ] = z;
	ABusinessData[BusID][BusinessType] = BusType;
	ABusinessData[BusID][BusinessLevel] = 1;
	ABusinessData[BusID][Owned] = false;

	// Add the pickup and 3DText at the location of the business-entrance (where the player is standing when he creates the business)
	Business_CreateEntrance(BusID);

	// Save the business
	BusinessFile_Save(BusID);

	// Inform the player that he created a new house
	format(Msg, 128, "{00FF00}Empresa criada com sucesso. ID{FF00FF}%i{00FF00}", BusID);
	SendClientMessage(playerid, 0xFFFFFFFF, Msg);

	return 1;
}

// This function processes the businessmenu dialog
Dialog_BusinessMenu(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new BusID, BusType, Msg[128], DialogTitle[200], UpgradePrice;

	// Get the HouseID of the house where the player is
	BusID = APlayerData[playerid][CurrentBusiness];
	BusType = ABusinessData[BusID][BusinessType];

	// Select an option based on the selection in the list
	switch(listitem)
	{
	    case 0: // Change business name
	    {
	        format(DialogTitle, 200, TXT_DialogOldBusinessName, ABusinessData[BusID][BusinessName]);
			ShowPlayerDialog(playerid, DialogBusinessNameChange, DIALOG_STYLE_INPUT, DialogTitle, TXT_DialogEnterNewBusinessName, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
	    }
	    case 1: // Upgrade the business
	    {
	        // Check if it's possible to upgrade further
			if (ABusinessData[BusID][BusinessLevel] < 5)
			{
			    // Get the upgrade-price
			    UpgradePrice = ABusinessInteriors[BusType][BusPrice];
			    // Check if the player can afford the upgrade
				if (APlayerData[playerid][PlayerMoney] >= UpgradePrice)
				{
				    // Give the current earnings of the business to the player and update the LastTransaction time
					Business_PayEarnings(playerid, BusID);
					// Upgrade the business 1 level
				    ABusinessData[BusID][BusinessLevel]++;
					// Let the player pay for the upgrade
					RewardPlayer(playerid, -UpgradePrice, 0);
					// Update the 3DText near the business's entrance to show what level the business is
					Business_UpdateEntrance(BusID);
					// Let the player know about it
					format(Msg, 128, "{00FF00}Você atualizou sua empresa para o level {FFFF00}%i.", ABusinessData[BusID][BusinessLevel]);
					SendClientMessage(playerid, 0xFFFFFFFF, Msg);
				}
				else
					SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não pode pagar pela atualização.");
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, TXT_BusinessReachedMaxLevel);
	    }
		case 2: // Retrieve business earnings
		{
		    // Give the current earnings of the business to the player and update the LastTransaction time
			Business_PayEarnings(playerid, BusID);
		}
		case 3: // Sell business
		{
		    format(Msg, 128, TXT_SureSellBusiness, (ABusinessInteriors[BusType][BusPrice] * ABusinessData[BusID][BusinessLevel]) / 2);
			ShowPlayerDialog(playerid, DialogSellBusiness, DIALOG_STYLE_MSGBOX, TXT_AreYouSure, Msg, TXT_DialogButtonYes, TXT_DialogButtonNo);
		}
	    case 4: // Exit the business
	    {
			Business_Exit(playerid, BusID);
	    }
	}

	return 1;
}
Dialog_GoBusiness(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new BusIndex, BusID;

	// The listitem directly indicates the business-index
	BusIndex = listitem;
	BusID = APlayerData[playerid][Business][BusIndex];

	// Check if this is a valid business (BusID != 0)
	if (BusID != 0)
	{
		// Get the coordinates of the business's entrance
		SetPlayerPos(playerid, ABusinessData[BusID][BusinessX], ABusinessData[BusID][BusinessY], ABusinessData[BusID][BusinessZ]);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, TXT_NoBusinessInSlot);

	return 1;
}

// Let the player change the name of his business
Dialog_ChangeBusinessName(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel" or if the player didn't input any text
	if ((!response) || (strlen(inputtext) == 0)) return 1;

	// Change the name of the business
	format(ABusinessData[APlayerData[playerid][CurrentBusiness]][BusinessName], 100, inputtext);
	// Also update the 3DText at the entrance of the business
	Business_UpdateEntrance(APlayerData[playerid][CurrentBusiness]);
	// Let the player know that the name of his business has been changed
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_ChangedBusinessName);

	// Save the player-file (and his houses and businesses)
	PlayerFile_Save(playerid);

	return 1;
}

// Sell the business
Dialog_SellBusiness(playerid, response)
{
	if(!response) return 1;

	new BusID = APlayerData[playerid][CurrentBusiness];
	new BusType = ABusinessData[BusID][BusinessType];
    new Msg[128];

	SetPlayerVirtualWorld(playerid, 0);
	SetPlayerInterior(playerid, 0);
	SetPlayerPos(playerid, ABusinessData[BusID][BusinessX], ABusinessData[BusID][BusinessY], ABusinessData[BusID][BusinessZ]);
	APlayerData[playerid][CurrentBusiness] = 0;
	ABusinessData[BusID][Owned] = false;
	ABusinessData[BusID][Owner] = 0;
	ABusinessData[BusID][BusinessName] = 0;
	ABusinessData[BusID][BusinessLevel] = 1;
	RewardPlayer(playerid, (ABusinessInteriors[BusType][BusPrice] * ABusinessData[BusID][BusinessLevel]) / 2, 0);
	SendClientMessage(playerid, 0xFFFFFFFF, TXT_PlayerSoldBusiness);
    format(Msg, 128, TXT_PlayerSellBusinessTxT, (ABusinessInteriors[BusType][BusPrice]*ABusinessData[BusID][BusinessLevel])/2);
    GameTextForPlayer(playerid, Msg, 5000, 1);         
    PlayerPlaySound(playerid, 1149, 0.0, 0.0, 0.0);

	for (new i; i < MAX_BUSINESSPERPLAYER; i++)
	{
		if (APlayerData[playerid][Business][i] == BusID)
		{
		    APlayerData[playerid][Business][i] = 0;
		    break;
		}
	}

	// Update the 3DText near the business's entrance to show other players that it's for sale again
	Business_UpdateEntrance(BusID);

	// Save the player-file (and his houses and businesses)
	PlayerFile_Save(playerid);
	// Also save the sold business, otherwise the old ownership-data is still there
	BusinessFile_Save(BusID);

	return 1;
}

// Process the commands dialog
Dialog_PlayerCommands(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response)
	{
		// Reset the FirstCommand (so the list won't start at an unexpected location in the list, but back at the start of the list)
		APlayerData[playerid][DialogFirstItem] = 0;
		return 1; // Exit the function
	}

	// Process the selected listitem
	switch (listitem)
	{
		case 11: // Player chooses "Next..."
		{
		    // Add 5 to the FirstCommand, so the list will start further down the array (will show the next 5 commands)
		    APlayerData[playerid][DialogFirstItem] = APlayerData[playerid][DialogFirstItem] + 5;
		    // Create a new list of commands and show the dialog
		    CommandList_Create(playerid);
		}
	}

	return 1;
}
Dialog_PrimaryCarColor(playerid, response, listitem)
{
	if(!response) return 1;
	new vid = GetPlayerVehicleID(playerid);
	AVehicleData[vid][Color1] = listitem;
	ChangeVehicleColor(GetPlayerVehicleID(playerid), AVehicleData[vid][Color1], AVehicleData[vid][Color2]);
	if (listitem == 0)
		AVehicleData[vid][PaintJob] = 0;
	RewardPlayer(playerid, -150, 0);
	SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Veículo pintado!");

	return 1;
}
Dialog_SedundaryCarColor(playerid, response, listitem)
{
	if(!response) return 1;
	new vid = GetPlayerVehicleID(playerid);
	AVehicleData[vid][Color2] = listitem;
	ChangeVehicleColor(GetPlayerVehicleID(playerid), AVehicleData[vid][Color1], AVehicleData[vid][Color2]);
	RewardPlayer(playerid, -150, 0);
	SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Veículo pintado!");

	return 1;
}
Dialog_UnclampVehicles(playerid, response)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new HouseID, vid, ClampedVehicles, UnclampPrice, Msg[128];

	// Loop through all vehicles owned by this player
	for (new HouseSlot; HouseSlot < MAX_HOUSESPERPLAYER; HouseSlot++)
	{
		// Get the HouseID that exists on this index
		HouseID = APlayerData[playerid][Houses][HouseSlot];

		// Check if this house-slot is used
		if (HouseID != 0)
		{
			// Loop through all vehicles assigned to this house
			for (new CarSlot; CarSlot < 10; CarSlot++)
			{
				// Get the vehicle-id of the vehicle in this carslot
				vid = AHouseData[HouseID][VehicleIDs][CarSlot];

				// Check if this carslot is used
				if (vid != 0)
				{
					// Check if this vehicle is clamped
					if (AVehicleData[vid][Clamped] == true)
					    ClampedVehicles++; // Count the clamped vehicles
				}
			}
		}
	}

	// Calculate the price to unclamp all the player's vehicles
	UnclampPrice = ClampedVehicles * UnclampPricePerVehicle;

	// Check if the player has enough cash to unclamp his vehicles
	if (APlayerData[playerid][PlayerMoney] >= UnclampPrice)
	{
		// Loop through all vehicles owned by this player
		for (new HouseSlot; HouseSlot < MAX_HOUSESPERPLAYER; HouseSlot++)
		{
			// Get the HouseID that exists on this index
			HouseID = APlayerData[playerid][Houses][HouseSlot];

			// Check if this house-slot is used
			if (HouseID != 0)
			{
				// Loop through all vehicles assigned to this house
				for (new CarSlot; CarSlot < 10; CarSlot++)
				{
					// Get the vehicle-id of the vehicle in this carslot
					vid = AHouseData[HouseID][VehicleIDs][CarSlot];

					// Check if this carslot is used
					if (vid != 0)
					{
						// Check if this vehicle is clamped
						if (AVehicleData[vid][Clamped] == true)
						    AVehicleData[vid][Clamped] = false; // Unclamp the vehicle
					}
				}
			}
		}
		RewardPlayer(playerid, -UnclampPrice, 0);
		format(Msg, 128, "{00FF00}Seus veiculos foram liberados por {FFFF00}R$%i.", UnclampPrice);
		SendClientMessage(playerid, 0xFFFFFFFF, Msg);
		PlayerFile_Save(playerid);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não tem dinheiro para liberar seus veiculos.");

	return 1;
}
Dialog_Rules(playerid, response)
{
	if(!response) return 1;
	if (APlayerData[playerid][RulesRead] == false)
	{
		RewardPlayer(playerid, 50000, 50);
		APlayerData[playerid][RulesRead] = true;
		SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Você ganhou {FFFF00}R$50000{00FF00} e {FFFF00}50 scores{00FF00} por aceitar as regras.");
		PlayerFile_Save(playerid);
	}

	return 1;
}
Dialog_StatsOtherPlayer(playerid, response, listitem)
{
	if(!response) return 1;
	new Name[24], DialogTitle[128], HouseList[1000], BusinessList[1000], BusID, BusType, Earnings, OtherPlayer, HouseID;

	// Get the ID of the other player
	OtherPlayer = APlayerData[playerid][DialogOtherPlayer];

	// If the player chose the line "Houses: xxx" or "Businesses: xxx", open a new dialog that displays them
	switch (listitem)
	{
		case 20: // Player chose to display the other player's houses
		{
			// Construct the dialog-title
			GetPlayerName(OtherPlayer, Name, sizeof(Name));
			format(DialogTitle, 128, "Casas do jogador: %s", Name);

			// Add all house-names of the other player to the list
			for (new i; i < MAX_HOUSESPERPLAYER; i++)
			{
			    // Get the HouseID
			    HouseID = APlayerData[OtherPlayer][Houses][i];

				// Check if this houseindex is occupied
				if (HouseID != 0)
					format(HouseList, 1000, "%s{00FF00}%s{FFFFFF}\n", HouseList, AHouseData[HouseID][HouseName]);
				else
					format(HouseList, 1000, "%s{FFFFFF}%s{FFFFFF}\n", HouseList, "slot vazio");
			}

			// Display the dialog (displays all statistics about the house, such as level, bought vehicles, insurance, ...)
			ShowPlayerDialog(playerid, DialogStatsHouse, DIALOG_STYLE_LIST, DialogTitle, HouseList, "Selecionar", "Cancelar");
		}
		case 21: // Player chose to display the other player's businesses
		{
			// Construct the dialog-title
			GetPlayerName(OtherPlayer, Name, sizeof(Name));
			format(DialogTitle, 128, "Empresas do jogador: %s", Name);

			// Ask to which business the player wants to port
			for (new i; i < MAX_BUSINESSPERPLAYER; i++)
			{
				// Get the business-id
			    BusID = APlayerData[OtherPlayer][Business][i];

				// Check if this businessindex is occupied
				if (BusID != 0)
				{
					// Get the business-type
					BusType = ABusinessData[BusID][BusinessType];
					Earnings = (BusinessTransactionTime - ABusinessData[BusID][LastTransaction]) * ABusinessInteriors[BusType][BusEarnings] * ABusinessData[BusID][BusinessLevel];
					format(BusinessList, 1000, "%s{00FF00}%s{FFFFFF} (ganhos: R$%i)\n", BusinessList, ABusinessData[BusID][BusinessName], Earnings);
				}
				else
					format(BusinessList, 1000, "%s{FFFFFF}%s{FFFFFF}\n", BusinessList, "slot vazio");
			}

			// Display the dialog (and allow the player to port there)
			ShowPlayerDialog(playerid, DialogStatsGoBusiness, DIALOG_STYLE_LIST, DialogTitle, BusinessList, "Ir para", "Cancelar");
		}
	}

	return 1;
}

// Process the chosen house from another player (displays the statistics of the chosen house)
Dialog_StatsHouse(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new OtherPlayer, HouseID, HouseData[2000], BuyableCarIndex, DialogTitle[128], Name[24];

	// Get the other player and chosen HouseID
	OtherPlayer = APlayerData[playerid][DialogOtherPlayer];
	HouseID = APlayerData[OtherPlayer][Houses][listitem];

	// Construct the dialog-title
	GetPlayerName(OtherPlayer, Name, sizeof(Name));
	format(DialogTitle, 128, "Casa do jogador: %s", Name);

	// Check if this is a valid HouseID
	if (HouseID != 0)
	{
		// Add all data about the house to the dialog
		format(HouseData, sizeof(HouseData), "%s{FFFFFF}Nome: {00FF00}%s\n", HouseData, AHouseData[HouseID][HouseName]);
		if (AHouseData[HouseID][Insurance] == 1)
			format(HouseData, sizeof(HouseData), "%s{FFFFFF}Seguro: {00FF00}Sim\n", HouseData);
		else
			format(HouseData, sizeof(HouseData), "%s{FFFFFF}Seguro: {00FF00}Nao\n", HouseData);

		format(HouseData, sizeof(HouseData), "%s{FFFFFF}Level: {00FF00}%i/%i\n", HouseData, AHouseData[HouseID][HouseLevel], AHouseData[HouseID][HouseMaxLevel]);
		format(HouseData, sizeof(HouseData), "%s{FFFFFF}Preço: {00FF00}%i\n \n", HouseData, AHouseData[HouseID][HousePrice]);
		format(HouseData, sizeof(HouseData), "%s{FFFFFF}Veiculos:\n", HouseData);

		// Add all vehicles to the list
		for (new CarSlot; CarSlot < 10; CarSlot++)
		{
			// Check if the carslot has a vehicle in it
			if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
			{
			    // Get the index where the first vehicle is found in the ABuyableVehicles array
			    BuyableCarIndex = VehicleBuyable_GetIndex(GetVehicleModel(AHouseData[HouseID][VehicleIDs][CarSlot]));
			    // Add the name of the vehicle to the list
				if (AVehicleData[AHouseData[HouseID][VehicleIDs][CarSlot]][Clamped] == true)
				    format(HouseData, 500, "%s{00FF00}%s (apreendido)\n", HouseData, ABuyableVehicles[BuyableCarIndex][CarName]);
				else
				    format(HouseData, 500, "%s{00FF00}%s\n", HouseData, ABuyableVehicles[BuyableCarIndex][CarName]);
			}
			else
				format(HouseData, 500, TXT_EmptyCarSlot, HouseData);
		}

		// Store the HouseID that was chosen of the other player so the other dialogs can display the statistics further
		APlayerData[playerid][DialogOtherPlayerHouse] = HouseID;

		// Display the dialog (and allow the player to port there)
		ShowPlayerDialog(playerid, DialogStatsGoHouse, DIALOG_STYLE_LIST, DialogTitle, HouseData, "Ir para", "Cancelar");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Não tem casas nesse slot.");

	return 1;
}

// Port to the house that was chosen by the player when viewing stats about a house and choosing "Goto"
Dialog_StatsGoHouse(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new HouseID, CarSlot, Float:x, Float:y, Float:z;

	// Get the HouseID
	HouseID = APlayerData[playerid][DialogOtherPlayerHouse];

	switch (listitem)
	{
	    case 6, 7, 8, 9, 10: // One of the cars in the list
	    {
			// Calculate the CarSlot
			CarSlot = listitem - 6;

			// Check if the carslot has a car in it
			if (AHouseData[HouseID][VehicleIDs][CarSlot] != 0)
			{
				// Get the position of the vehicle
				GetVehiclePos(AHouseData[HouseID][VehicleIDs][CarSlot], x, y, z);
				// Port the player to the vehicle
				SetPlayerPos(playerid, x, y, z);
			}
			else
			    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Não ha veiculo nesse slot.");
	    }
	    default: // Any other line
		{
			// Port the player to the house entrance
			SetPlayerPos(playerid, AHouseData[HouseID][HouseX], AHouseData[HouseID][HouseY], AHouseData[HouseID][HouseZ]);
		}
	}

	return 1;
}

// Process the chosen business from another player to port to
Dialog_StatsGoBusiness(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new BusIndex, BusID;

	// The listitem directly indicates the business-index
	BusIndex = listitem;
	BusID = APlayerData[APlayerData[playerid][DialogOtherPlayer]][Business][BusIndex];

	// Check if this is a valid business (BusID != 0)
	if (BusID != 0)
	{
		// Get the coordinates of the business's entrance
		SetPlayerPos(playerid, ABusinessData[BusID][BusinessX], ABusinessData[BusID][BusinessY], ABusinessData[BusID][BusinessZ]);
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Não ha empresas nesse slot.");

	return 1;
}



// Process the password to register a bank account
Dialog_BankPasswordRegister(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Check if the player entered a valid password
	if ((strlen(inputtext) > 0) && (strlen(inputtext) < 20))
	{
		// Store the password
		format(APlayerData[playerid][BankPassword], 24, inputtext);
		// Save the bank account
		BankFile_Save(playerid);
		// Inform the player that he has succesfully registered a bank account
		SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Você registrou a conta bancária com sucesso!");
	}
	else
		SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você precisa usar uma senha válida pra registrar a conta.");

	return 1;
}

// Process the password to login to your bank account
Dialog_BankPasswordLogin(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Check if the player entered a valid password
	if ((strlen(inputtext) > 0) && (strlen(inputtext) < 20))
	{
		// Check if the player entered the correct password to login to his bank account
	    if (strcmp(APlayerData[playerid][BankPassword], inputtext, false) == 0)
		{
			// The player has logged in to his bank account
	       	APlayerData[playerid][BankLoggedIn] = true;
			// Inform the player that he has succesfully registered a bank account
			SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Conta bancária logada!");
			// Show the bank dialog
			ShowBankMenu(playerid);
		}
		else // The player entered the wrong password
			SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Senha incorreta!");
	}
	else
		SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Use a senha correta.");

	return 1;
}

// Process the options in the bank dialog
Dialog_BankOptions(playerid, response, listitem)
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new DialogMsg[500];

	// Check what to do based on which option is chosen
	switch (listitem)
	{
	    case 0: // Deposit funds in your bank account
		{
		    format(DialogMsg, sizeof(DialogMsg), "{FFFFFF}Seu dinhero: {00FF00}R$%i\n", APlayerData[playerid][PlayerMoney]);
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Conta bancaria: {00FF00}R$%i\n \n", DialogMsg, APlayerData[playerid][BankMoney]);
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Insira a quantidade de dinheiro que deseja depsitar:", DialogMsg);
			ShowPlayerDialog(playerid, DialogBankDeposit, DIALOG_STYLE_INPUT, "insira a quantidade de dinheiro", DialogMsg, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
		}
	    case 1: // Withdraw funds from your bank account
		{
		    // Check if you have any money in your bank account to withdraw from it
		    if (APlayerData[playerid][BankMoney] > 0)
		    {
			    format(DialogMsg, sizeof(DialogMsg), "{FFFFFF}Seu dinheiro: {00FF00}R$%i\n", APlayerData[playerid][PlayerMoney]);
			    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Conta bancaria: {00FF00}R$%i\n \n", DialogMsg, APlayerData[playerid][BankMoney]);
			    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Insira a quantidade de dinheiro que deseja retirar:", DialogMsg);
				ShowPlayerDialog(playerid, DialogBankWithdraw, DIALOG_STYLE_INPUT, "insira a quantidade de dinheiro", DialogMsg, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
			}
			else
				SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Voce nao pode sacar dinheiro da conta vazia.");
		}
	    case 2: // Transfer funds from your bank account to another player's bank account
		{
		    // Check if you have any money in your bank account to transfer from it
		    if (APlayerData[playerid][BankMoney] > 0)
		    {
			    format(DialogMsg, sizeof(DialogMsg), "{FFFFFF}Seu dinheiro: {00FF00}R$%i\n", APlayerData[playerid][PlayerMoney]);
			    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Conta bancaria: {00FF00}R$%i\n \n", DialogMsg, APlayerData[playerid][BankMoney]);
			    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Insira a quantidade de dinheiro que deseja transferir:", DialogMsg);
				ShowPlayerDialog(playerid, DialogBankTransferMoney, DIALOG_STYLE_INPUT, "insira a quantidade de dinheiro", DialogMsg, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
			}
			else
				SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Voce nao pode transferir dinheiro com a conta vazia.");
		}
		case 3: // Cancel your bank account
		{
			if (APlayerData[playerid][BankMoney] > 0)
			{
			    format(DialogMsg, sizeof(DialogMsg), "{FFFFFF}Sua conta bancária possui {00FF00}R$%i{FFFFFF} em cofre.\n", APlayerData[playerid][BankMoney]);
			    format(DialogMsg, sizeof(DialogMsg), "%s {FFFFFF}Fundos de seu banco será devolvido a você quando você cancelar a sua conta bancária\n", DialogMsg, APlayerData[playerid][BankMoney]);
			}
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Tem certeza de que deseja cancelar sua conta bancária?", DialogMsg);

			// Ask the player if he's sure he wants to cancel his bank account
			ShowPlayerDialog(playerid, DialogBankCancel, DIALOG_STYLE_MSGBOX, TXT_AreYouSure, DialogMsg, TXT_DialogButtonYes, TXT_DialogButtonNo);
		}
	}

	return 1;
}

// Process the entered amount of money that needs to be deposited into the player's bank account
Dialog_BankDeposit(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new DepositMoney, Msg[128];

	// Convert the entered text into an integer
	DepositMoney = strval(inputtext);

	// Check if the player entered a positive amount of money
	if (DepositMoney > 0)
	{
		// Check if the player has enough money
		if (DepositMoney <= APlayerData[playerid][PlayerMoney])
		{
			// Add the money to your bank account
	        APlayerData[playerid][BankMoney] = APlayerData[playerid][BankMoney] + DepositMoney;
			// Take the money away from yourself
			APlayerData[playerid][PlayerMoney] = APlayerData[playerid][PlayerMoney] - DepositMoney;
			// Save the player's account
			PlayerFile_Save(playerid);
			// Save the bank account
			BankFile_Save(playerid);
			// Inform the player that his money has been deposited
			format(Msg, 128, "{00FF00}Você depositou {FFFF00}R$%i{00FF00} na sua conta bancária.", DepositMoney);
			SendClientMessage(playerid, 0xFFFFFFFF, Msg);
			// Show the bank dialog
			ShowBankMenu(playerid);
		}
		else
		    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não tem essa quantidade de dinheiro para depositar em sua conta bancária.");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você precisa digitar um valor positivo de dinheiro para depositar em sua conta bancária");

	return 1;
}

// Process the entered amount of money that needs to be withdrawn from the player's bank account
Dialog_BankWithdraw(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new WithdrawMoney, Msg[128];

	// Convert the entered text into an integer
	WithdrawMoney = strval(inputtext);

	// Check if the player entered a positive amount of money
	if (WithdrawMoney > 0)
	{
		// Check if the player has enough money in his bank account
		if (WithdrawMoney <= APlayerData[playerid][BankMoney])
		{
			// Withdraw the money from your bank account
	        APlayerData[playerid][BankMoney] = APlayerData[playerid][BankMoney] - WithdrawMoney;
			// Give the money to yourself
			APlayerData[playerid][PlayerMoney] = APlayerData[playerid][PlayerMoney] + WithdrawMoney;
			// Save the player's account
			PlayerFile_Save(playerid);
			// Save the bank account
			BankFile_Save(playerid);
			// Inform the player that his money has been withdrawn
			format(Msg, 128, "{00FF00}Você sacou {FFFF00}R$%i{00FF00} de sua conta bancária.", WithdrawMoney);
			SendClientMessage(playerid, 0xFFFFFFFF, Msg);
			// Show the bank dialog
			ShowBankMenu(playerid);
		}
		else
		    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não tem essa quantidade de dinheiro em sua conta bancária para retirar.");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}É necessário introduzir um saldo positivo de dinheiro para retirar da sua conta bancária.");

	return 1;
}

// Process the transfer option (player entered the amount of money to transfer to another player)
Dialog_BankTransferMoney(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new DialogMsg[500];

	// Check if there is a text entered
	if (strlen(inputtext) == 0)
	{
		// Let the player know he must enter a valid amount of money into the input field
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você precisa digitar um valor válido de dinheiro.");
		return 1;
	}

	// Convert the entered text into an integer and store it
	APlayerData[playerid][UseMoney] = strval(inputtext);

	// Check if the player entered a valid amount of money to be transferred
	if (APlayerData[playerid][UseMoney] > 0)
	{
		// Check if the player has enough money in his bank account to transfer it to another player's account
		if (APlayerData[playerid][UseMoney] <= APlayerData[playerid][BankMoney])
		{
			// Ask the player to which account he wants to transfer the money
		    format(DialogMsg, sizeof(DialogMsg), "{FFFFFF}Seu dinheiro: {00FF00}R$%i\n", APlayerData[playerid][PlayerMoney]);
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Seus fundos: {00FF00}R$%i\n", DialogMsg, APlayerData[playerid][BankMoney]);
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Valor da transferência solicitada: {00FF00}R$%i\n \n", DialogMsg, APlayerData[playerid][UseMoney]);
		    format(DialogMsg, sizeof(DialogMsg), "%s{FFFFFF}Por favor, insira o nome do jogador que deve receber a sua transferência de dinheiro:", DialogMsg);
			ShowPlayerDialog(playerid, DialogBankTransferName, DIALOG_STYLE_INPUT, "Enter player name", DialogMsg, TXT_DialogButtonSelect, TXT_DialogButtonCancel);
		}
		else
		    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você não tem essa quantidade de dinheiro em sua conta bancária para transferência para a conta de outro jogador.");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}É necessário introduzir um saldo positivo de dinheiro para transferir dinheiro para conta de outro jogador");

	return 1;
}

// Process the transfer option (player entered the name of the other player who must receive the money)
Dialog_BankTransferName(playerid, response, inputtext[])
{
	// Just close the dialog if the player clicked "Cancel"
	if(!response) return 1;

	// Setup local variables
	new file[100], File:BFile, LineForFile[100], ReceiverName[24], SenderName[24], Msg[128];
	new OtherPlayer, Day, Month, Year, Hour, Minute, Second, sDay[3], sMonth[3], sYear[5], sHour[3], sMinute[3];

    // Get the playername of the sender (the player who executes the transfer)
	format(SenderName, sizeof(SenderName), APlayerData[playerid][PlayerName]);

	// Check if there is a text entered
	if (strlen(inputtext) == 0)
	{
		// Let the player know he must enter a playername or playerid into the input field
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você precisa digitar o NICK ou o ID.");
		return 1;
	}

	// Try to convert the given playername OR playerid to a playerid
	sscanf(inputtext, "u", OtherPlayer);

	// Check if an online player was found by sscanf
	if (OtherPlayer != INVALID_PLAYER_ID)
	{
		// Check if that other player is online (use online bank-transfer)
		if (APlayerData[OtherPlayer][LoggedIn] == true)
		{
			format(ReceiverName, sizeof(ReceiverName), APlayerData[OtherPlayer][PlayerName]); // Get the playername of the receiver
			format(file, sizeof(file), BankFile, ReceiverName); // Construct the complete filename for the receiver's bank-account

			// Check if the receiver has a bank account
			if (fexist(file))
			{
			    // Transfer the money from your bank account to the other player's bank account
			    APlayerData[OtherPlayer][BankMoney] = APlayerData[OtherPlayer][BankMoney] + APlayerData[playerid][UseMoney];
				// Take the money away from your own bank account
				APlayerData[playerid][BankMoney] = APlayerData[playerid][BankMoney] - APlayerData[playerid][UseMoney];
				// Save both bank accounts
				BankFile_Save(OtherPlayer);
				BankFile_Save(playerid);
				// Inform the receiver that money was transferred to his bank account
				format(Msg, 128, "{00FF00}Sua conta bancária tem recebido uma transferência de {FFFF00}R$%i{00FF00} recebida de {FFFF00}%s", APlayerData[playerid][UseMoney], SenderName);
				SendClientMessage(OtherPlayer, 0xFFFFFFFF, Msg);
				// Inform the sender that money was transferred from his bank account to the receiver
				format(Msg, 128, "{00FF00}Você transferiu {FFFF00}R$%i{00FF00} para a conta bancária de {FFFF00}%s{00FF00}", APlayerData[playerid][UseMoney], ReceiverName);
				SendClientMessage(playerid, 0xFFFFFFFF, Msg);
				// Exit the function (bank transfer was completed), skipping offline transfer
				return 1;
			}
			else // The target player is online, but has no bank account
			{
				format(Msg, 128, "{FF0000}[FALHA NA TRANSFERÊNCIA] O jogador {FFFF00}%s{FF0000} está online, mas não tem conta bancária.", inputtext);
			    SendClientMessage(playerid, 0xFFFFFFFF, Msg);
				// Exit the function (bank transfer failed as the target player has no bank account), skipping offline transfer
				return 1;
			}
		}
		else
		{
		}
	}
	format(file, sizeof(file), BankFile, inputtext);
	if (fexist(file))
	{
		BFile = fopen(file, io_append);
		fwrite(BFile, "[Transfer]\r\n");
		format(LineForFile, 100, "TransferMoney %i\r\n", APlayerData[playerid][UseMoney]);
		fwrite(BFile, LineForFile);
		format(LineForFile, 100, "TransferName %s\r\n", SenderName);
		fwrite(BFile, LineForFile);
		getdate(Year, Month, Day);
		gettime(Hour, Minute, Second);
		if (Day < 10) format(sDay, sizeof(sDay), "0%i", Day);
		else format(sDay, sizeof(sDay), "%i", Day);
		if (Month < 10) format(sMonth, sizeof(sMonth), "0%i", Month);
		else format(sMonth, sizeof(sMonth), "%i", Month);
	    format(sYear, sizeof(sYear), "%i", Year);
		if (Hour < 10) format(sHour, sizeof(sHour), "0%i", Hour);
		else format(sHour, sizeof(sHour), "%i", Hour);
		if (Minute < 10) format(sMinute, sizeof(sMinute), "0%i", Minute);
		else format(sMinute, sizeof(sMinute), "%i", Minute);

		format(LineForFile, 100, "TransferTime %s/%s/%s %s:%s\r\n", sDay, sMonth, sYear, sHour, sMinute);
		fwrite(BFile, LineForFile);
		fwrite(BFile, "[/Transfer]\r\n");
		fclose(BFile);
		APlayerData[playerid][BankMoney] = APlayerData[playerid][BankMoney] - APlayerData[playerid][UseMoney];
		BankFile_Save(playerid);
		format(Msg, 128, "{00FF00}O jogador {FFFF00}%s{00FF00} está offline e tem uma conta bancária, transferência de {FFFF00}R$%i{00FF00}, COMPLETA!", inputtext, APlayerData[playerid][UseMoney]);
		SendClientMessage(playerid, 0xFFFFFFFF, Msg);
	}
	else
	{
		format(Msg, 128, "{FF0000}[FALHA NA TRANSFERÊNCIA] Nome da conta {FFFF00}%s{FF0000} não existe.", inputtext);
	    SendClientMessage(playerid, 0xFFFFFFFF, Msg);
	}

	return 1;
}
Dialog_BankCancel(playerid, response)
{
	if(!response) return 1;
	new file[100], Name[24];
	format(Name, sizeof(Name), APlayerData[playerid][PlayerName]);
	format(file, sizeof(file), BankFile, Name);
	if (fexist(file))
		fremove(file); 
	RewardPlayer(playerid, APlayerData[playerid][BankMoney], 0);
	if (APlayerData[playerid][BankMoney] > 0)
	    SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Havia ainda algum dinheiro em sua conta bancária, e foi lhe devolvido.");
	PlayerFile_Save(playerid);
	APlayerData[playerid][BankPassword] = 0;
	APlayerData[playerid][BankLoggedIn] = false;
	APlayerData[playerid][BankMoney] = 0;
	SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Sua conta bancária foi excluída.");

	return 1;
}
Dialog_HelpItemChosen(playerid, response, listitem)
{
	if(!response) return 1;
	new DialogTitle[128];
	format(DialogMsg5000, 5000, "");
	format(DialogTitle, 128, AHelpTopics[listitem]);
	for (new i; i < sizeof(AHelpText); i++)
	{
		if (AHelpText[i][HelpID] == listitem)
		{
			format(DialogMsg5000, 5000, "%s%s\n", DialogMsg5000, AHelpText[i][HelpText]);
		}
	}
	ShowPlayerDialog(playerid, DialogHelpItem, DIALOG_STYLE_MSGBOX, DialogTitle, DialogMsg5000, "Back", TXT_DialogButtonCancel);
	return 1;
}
Dialog_HelpItem(playerid, response)
{
	if(!response) return 1;
	HelpList_Create(playerid);

	return 1;
}
Dialog_OldPassword(playerid, response, inputtext[])
{
	if(!response) return 1;
    if (strcmp(APlayerData[playerid][PlayerPassword], inputtext, false) == 0)
	{
		ShowPlayerDialog(playerid, DialogNewPassword, DIALOG_STYLE_INPUT, "Insira a nova senha:", "Insira a nova senha:", "OK", "Cancelar");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Você digitou a senha errada.");

	return 1;
}
Dialog_NewPassword(playerid, response, inputtext[])
{
	if(!response) return 1;
	new Msg[256];
    if (strlen(inputtext) > 0)
	{
	    if (strcmp(APlayerData[playerid][PlayerPassword], inputtext, false) != 0)
		{
			format(APlayerData[playerid][PlayerNewPassword], 50, inputtext);
			format(Msg, 256, "{FFFFFF}Senha antiga: \t{00FF00}%s{FFFFFF}\n", APlayerData[playerid][PlayerPassword]);
			format(Msg, 256, "%sSenha nova: \t{00FF00}%s{FFFFFF}\n \n", Msg, APlayerData[playerid][PlayerNewPassword]);
			format(Msg, 256, "%sTem certeza de que deseja alterar sua senha?", Msg);
			ShowPlayerDialog(playerid, DialogConfirmPassword, DIALOG_STYLE_MSGBOX, "Tem certeza?", Msg, "Sim", "Não");
		}
		else
		    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Sua nova senha não pode ser a mesma que a senha antiga.");
	}
	else
	    SendClientMessage(playerid, 0xFFFFFFFF, "{FF0000}Senha inválida.");

	return 1;
}
Dialog_ConfirmPassword(playerid, response)
{
	if(!response) return 1;
	format(APlayerData[playerid][PlayerPassword], 50, APlayerData[playerid][PlayerNewPassword]);
	format(APlayerData[playerid][PlayerNewPassword], 50, "");
    SendClientMessage(playerid, 0xFFFFFFFF, "{00FF00}Sua senha foi alterada!");
	PlayerFile_Save(playerid);
	return 1;
}

